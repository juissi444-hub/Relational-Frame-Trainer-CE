<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Relational Frame Trainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body { 
            margin: 0; 
            font-family: system-ui, -apple-system, sans-serif; 
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: pan-y;
        }
        .emoji-stimulus { font-size: 2rem; line-height: 1; }
        .transition-colors { transition: background-color 0.3s, color 0.3s, border-color 0.3s; }
        input[type="range"] { 
            -webkit-appearance: none; 
            appearance: none; 
            height: 8px; 
            border-radius: 5px; 
            background: #ddd; 
            outline: none;
            touch-action: none;
        }
        input[type="range"]::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 24px; 
            height: 24px; 
            border-radius: 50%; 
            background: #6366f1; 
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb { 
            width: 24px; 
            height: 24px; 
            border-radius: 50%; 
            background: #6366f1; 
            cursor: pointer; 
            border: none;
        }
        .dark input[type="range"] { background: #475569; }
        button { 
            cursor: pointer;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        button:active { transform: scale(0.95); }
        .premise-item { transition: transform 0.2s; }
        .main-content-wrapper { 
            height: 100%; 
            overflow-y: auto; 
            overflow-x: hidden; 
            -webkit-overflow-scrolling: touch;
        }
        @media (max-width: 640px) {
            .main-content-wrapper { 
                padding-bottom: env(safe-area-inset-bottom, 20px); 
            }
            button {
                min-height: 44px;
                min-width: 44px;
            }
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script>
        const state = {
            timePerQuestion: 30,
            networkComplexity: 0.5,
            spoilerPremises: false,
            darkMode: false,
            useLetters: true,
            useEmojis: false,
            useVoronoi: false,
            useMandelbrot: false,
            letterLength: 3,
            autoProgressEnabled: true,
            universalAutoProgress: true,
            targetPremiseCount: 40,
            targetAccuracy: 95,
            recentAnswers: [],
            statsHistory: [],
            showSettings: false,
            showHistory: false,
            showStats: false,
            showTutorial: false,
            isPaused: false,
            currentTrial: null,
            timeLeft: 30,
            score: { correct: 0, incorrect: 0, missed: 0 },
            feedback: null,
            history: [],
            hoveredPremise: null,
            enabledRelationModes: {
                equality: true,
                temporal: false,
                spatial: false,
                containment: false
            },
            premiseCounts: {
                equality: 3,
                temporal: 3,
                spatial: 3,
                containment: 3
            },
            modeProgress: {
                equality: { recentAnswers: [], timePerQuestion: 30 },
                temporal: { recentAnswers: [], timePerQuestion: 30 },
                spatial: { recentAnswers: [], timePerQuestion: 30 },
                containment: { recentAnswers: [], timePerQuestion: 30 }
            }
        };

        const relationSets = {
            equality: ['SAME', 'OPPOSITE', 'DIFFERENT'],
            temporal: ['BEFORE', 'AFTER', 'AT'],
            spatial: ['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'],
            containment: ['CONTAINS', 'WITHIN']
        };

        const emojiList = ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ¤£', 'ðŸ˜‚', 'ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜š', 'ðŸ˜™', 'ðŸ¥²', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜', 'ðŸ¤‘', 'ðŸ¤—', 'ðŸ¤­', 'ðŸ¤«', 'ðŸ¤”', 'ðŸ¤', 'ðŸ¤¨', 'ðŸ˜', 'ðŸ˜‘', 'ðŸ˜¶', 'ðŸ˜', 'ðŸ˜’', 'ðŸ™„', 'ðŸ˜¬', 'ðŸ¤¥', 'ðŸ˜Œ', 'ðŸ˜”', 'ðŸ˜ª', 'ðŸ¤¤', 'ðŸ˜´'];

        let timerId = null;

        function saveToStorage() {
            const progressData = {
                score: state.score,
                history: state.history,
                statsHistory: state.statsHistory,
                settings: {
                    timePerQuestion: state.timePerQuestion,
                    networkComplexity: state.networkComplexity,
                    spoilerPremises: state.spoilerPremises,
                    darkMode: state.darkMode,
                    useLetters: state.useLetters,
                    useEmojis: state.useEmojis,
                    useVoronoi: state.useVoronoi,
                    useMandelbrot: state.useMandelbrot,
                    letterLength: state.letterLength,
                    autoProgressEnabled: state.autoProgressEnabled,
                    universalAutoProgress: state.universalAutoProgress,
                    targetPremiseCount: state.targetPremiseCount,
                    targetAccuracy: state.targetAccuracy,
                    enabledRelationModes: state.enabledRelationModes,
                    premiseCounts: state.premiseCounts,
                    modeProgress: state.modeProgress
                },
                recentAnswers: state.recentAnswers
            };
            
            try {
                localStorage.setItem('rft-data', JSON.stringify(progressData));
            } catch (error) {
                console.error('Save failed:', error);
            }
        }

        function loadFromStorage() {
            try {
                const data = localStorage.getItem('rft-data');
                if (data) {
                    const parsed = JSON.parse(data);
                    if (parsed.score) state.score = parsed.score;
                    if (parsed.history) state.history = parsed.history;
                    if (parsed.statsHistory) state.statsHistory = parsed.statsHistory;
                    if (parsed.recentAnswers) state.recentAnswers = parsed.recentAnswers;
                    if (parsed.settings) {
                        Object.keys(parsed.settings).forEach(key => {
                            if (parsed.settings[key] !== undefined) {
                                state[key] = parsed.settings[key];
                            }
                        });
                    }
                }
            } catch (error) {
                console.log('No saved data found');
            }
        }

        function getRelationMode(relation) {
            if (['SAME', 'OPPOSITE', 'DIFFERENT'].includes(relation)) return 'equality';
            if (['BEFORE', 'AFTER', 'AT'].includes(relation)) return 'temporal';
            if (['CONTAINS', 'WITHIN'].includes(relation)) return 'containment';
            return 'spatial';
        }

        function deriveRelation(rel1, rel2) {
            const mode1 = getRelationMode(rel1);
            const mode2 = getRelationMode(rel2);
            
            if (mode1 !== mode2) return 'AMBIGUOUS';
            
            if (mode1 === 'equality') {
                if (rel1 === 'SAME') return rel2;
                if (rel2 === 'SAME') return rel1;
                if (rel1 === 'OPPOSITE' && rel2 === 'OPPOSITE') return 'SAME';
                if (rel1 === 'DIFFERENT' || rel2 === 'DIFFERENT') return 'AMBIGUOUS';
                return 'AMBIGUOUS';
            } else if (mode1 === 'temporal') {
                if (rel1 === 'AT') return rel2;
                if (rel2 === 'AT') return rel1;
                if (rel1 === 'BEFORE' && rel2 === 'BEFORE') return 'BEFORE';
                if (rel1 === 'AFTER' && rel2 === 'AFTER') return 'AFTER';
                return 'AMBIGUOUS';
            } else if (mode1 === 'containment') {
                if (rel1 === 'CONTAINS' && rel2 === 'CONTAINS') return 'CONTAINS';
                if (rel1 === 'WITHIN' && rel2 === 'WITHIN') return 'WITHIN';
                return 'AMBIGUOUS';
            } else {
                if (rel1 === rel2) return rel1;
                return 'AMBIGUOUS';
            }
        }

        function findAllPaths(graph, start, end, currentPath = [], visited = new Set(), allPaths = []) {
            if (start === end && currentPath.length > 0) {
                allPaths.push([...currentPath]);
                return allPaths;
            }
            visited.add(start);
            for (const edge of graph) {
                let nextNode = null, edgeToAdd = null;
                if (edge.stimulus1 === start && !visited.has(edge.stimulus2)) {
                    nextNode = edge.stimulus2;
                    edgeToAdd = { ...edge, reversed: false };
                } else if (edge.stimulus2 === start && !visited.has(edge.stimulus1)) {
                    nextNode = edge.stimulus1;
                    const reversedRelation = (edge.relation === 'CONTAINS') ? 'WITHIN' : 
                                            (edge.relation === 'WITHIN') ? 'CONTAINS' : edge.relation;
                    edgeToAdd = { ...edge, relation: reversedRelation, reversed: true };
                }
                if (nextNode) {
                    currentPath.push(edgeToAdd);
                    findAllPaths(graph, nextNode, end, currentPath, new Set(visited), allPaths);
                    currentPath.pop();
                }
            }
            return allPaths;
        }

        function deriveFromPath(path) {
            if (!path || path.length === 0) return null;
            let result = path[0].relation;
            for (let i = 1; i < path.length; i++) {
                result = deriveRelation(result, path[i].relation);
                if (result === 'AMBIGUOUS') return 'AMBIGUOUS';
            }
            return result;
        }

        function deriveRelationFromGraph(graph, start, end) {
            if (start === end) {
                if (state.enabledRelationModes.equality) return 'SAME';
                if (state.enabledRelationModes.temporal) return 'AT';
                return null;
            }
            const allPaths = findAllPaths(graph, start, end);
            if (allPaths.length === 0) return null;
            
            const derivedRelations = allPaths.map(path => deriveFromPath(path)).filter(r => r !== null);
            if (derivedRelations.length === 0) return null;
            
            const nonAmbiguous = derivedRelations.filter(r => r !== 'AMBIGUOUS');
            if (nonAmbiguous.length === 0) return 'AMBIGUOUS';
            
            const firstRel = nonAmbiguous[0];
            const allAgree = nonAmbiguous.every(rel => rel === firstRel);
            
            return allAgree ? firstRel : 'AMBIGUOUS';
        }

        function generateStimulus() {
            const availableTypes = [];
            if (state.useLetters) availableTypes.push('letters');
            if (state.useEmojis) availableTypes.push('emojis');
            if (state.useVoronoi) availableTypes.push('voronoi');
            if (state.useMandelbrot) availableTypes.push('mandelbrot');
            
            if (availableTypes.length === 0) availableTypes.push('letters');
            
            const selectedType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            if (selectedType === 'emojis') {
                return emojiList[Math.floor(Math.random() * emojiList.length)];
            } else if (selectedType === 'voronoi') {
                return `voronoi_${Math.floor(Math.random() * 1000000)}`;
            } else if (selectedType === 'mandelbrot') {
                return `mandelbrot_${Math.floor(Math.random() * 1000000)}`;
            } else {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < state.letterLength; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }
        }

        function generateVoronoiSVG(seed) {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
            const random = (s) => { const x = Math.sin(s++) * 10000; return x - Math.floor(x); };
            
            let svgContent = '<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="border-radius: 0.375rem;">';
            const gridSize = 4;
            const tileSize = 64 / gridSize;
            
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const colorIndex = Math.floor(random(seed + row * gridSize + col) * colors.length);
                    const color = colors[colorIndex];
                    const x = col * tileSize;
                    const y = row * tileSize;
                    svgContent += `<rect x="${x}" y="${y}" width="${tileSize}" height="${tileSize}" fill="${color}" opacity="0.9"/>`;
                }
            }
            svgContent += '</svg>';
            return svgContent;
        }

        function generateMandelbrotSVG(seed) {
            const random = (s) => { const x = Math.sin(s++) * 10000; return x - Math.floor(x); };
            const centerX = -0.7 + (random(seed) - 0.5) * 0.5;
            const centerY = 0 + (random(seed + 100) - 0.5) * 0.5;
            const zoom = 0.3 + random(seed + 200) * 0.7;
            
            const width = 64, height = 64, maxIterations = 50;
            let svgContent = '<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="border-radius: 0.375rem;">';
            const colors = ['#000033', '#000055', '#0000AA', '#0000FF', '#0055FF', '#00AAFF', '#00FFFF', '#55FFAA'];
            
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x0 = centerX + (px / width - 0.5) * zoom;
                    const y0 = centerY + (py / height - 0.5) * zoom;
                    let x = 0, y = 0, iteration = 0;
                    
                    while (x * x + y * y <= 4 && iteration < maxIterations) {
                        const xtemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xtemp;
                        iteration++;
                    }
                    
                    const color = iteration === maxIterations ? '#000000' : colors[Math.floor((iteration / maxIterations) * (colors.length - 1))];
                    svgContent += `<rect x="${px}" y="${py}" width="1" height="1" fill="${color}"/>`;
                }
            }
            svgContent += '</svg>';
            return svgContent;
        }

        function generateTrial() {
            const enabledModes = Object.keys(state.enabledRelationModes).filter(mode => state.enabledRelationModes[mode]);
            const chosenMode = enabledModes.length > 0 ? enabledModes[Math.floor(Math.random() * enabledModes.length)] : 'equality';
            const activeRelations = relationSets[chosenMode];
            
            const premiseCount = state.premiseCounts[chosenMode];
            const numStimuli = Math.max(3, premiseCount + 1);
            const stimuli = [generateStimulus()];
            const premises = [];
            
            for (let p = 0; p < premiseCount; p++) {
                let chosenPair = null;
                const ambiguousPairs = [];
                
                for (let i = 0; i < stimuli.length; i++) {
                    for (let j = i + 1; j < stimuli.length; j++) {
                        const s1 = stimuli[i], s2 = stimuli[j];
                        const alreadyConnected = premises.some(pr => (pr.stimulus1 === s1 && pr.stimulus2 === s2) || (pr.stimulus1 === s2 && pr.stimulus2 === s1));
                        if (!alreadyConnected) {
                            const derived = deriveRelationFromGraph(premises, s1, s2);
                            if (derived === 'AMBIGUOUS') ambiguousPairs.push({ s1, s2 });
                        }
                    }
                }
                
                if (ambiguousPairs.length > 0 && Math.random() < state.networkComplexity) {
                    chosenPair = ambiguousPairs[Math.floor(Math.random() * ambiguousPairs.length)];
                } else if (stimuli.length < numStimuli) {
                    const newStimulus = generateStimulus();
                    stimuli.push(newStimulus);
                    chosenPair = { s1: stimuli[Math.floor(Math.random() * (stimuli.length - 1))], s2: newStimulus };
                } else {
                    const availablePairs = [];
                    for (let i = 0; i < stimuli.length; i++) {
                        for (let j = i + 1; j < stimuli.length; j++) {
                            const s1 = stimuli[i], s2 = stimuli[j];
                            if (!premises.some(pr => (pr.stimulus1 === s1 && pr.stimulus2 === s2) || (pr.stimulus1 === s2 && pr.stimulus2 === s1))) {
                                availablePairs.push({ s1, s2 });
                            }
                        }
                    }
                    chosenPair = availablePairs.length > 0 ? availablePairs[Math.floor(Math.random() * availablePairs.length)] : { s1: stimuli[0], s2: stimuli[1] };
                }
                
                if (chosenPair) {
                    premises.push({
                        stimulus1: chosenPair.s1,
                        relation: activeRelations[Math.floor(Math.random() * activeRelations.length)],
                        stimulus2: chosenPair.s2
                    });
                }
            }
            
            const startIdx = Math.floor(Math.random() * stimuli.length);
            let endIdx = Math.floor(Math.random() * stimuli.length);
            if (startIdx === endIdx) endIdx = (endIdx + 1) % stimuli.length;
            
            const derivedRelation = deriveRelationFromGraph(premises, stimuli[startIdx], stimuli[endIdx]);
            let questionRelation, correctAnswer;
            
            if (derivedRelation === 'AMBIGUOUS' || derivedRelation === null) {
                questionRelation = activeRelations[Math.floor(Math.random() * activeRelations.length)];
                correctAnswer = 'ambiguous';
            } else {
                const askCompatible = Math.random() < 0.5;
                if (askCompatible) {
                    questionRelation = derivedRelation;
                    correctAnswer = true;
                } else {
                    const incompatible = activeRelations.filter(r => r !== derivedRelation);
                    if (incompatible.length > 0) {
                        questionRelation = incompatible[Math.floor(Math.random() * incompatible.length)];
                        correctAnswer = false;
                    } else {
                        questionRelation = derivedRelation;
                        correctAnswer = true;
                    }
                }
            }

            return {
                premises,
                question: { stimulus1: stimuli[startIdx], relation: questionRelation, stimulus2: stimuli[endIdx] },
                correctAnswer,
                derivedRelation: derivedRelation || 'AMBIGUOUS',
                allStimuli: stimuli,
                mode: chosenMode
            };
        }

        function startNewTrial() {
            state.currentTrial = generateTrial();
            const mode = state.currentTrial.mode;
            state.timeLeft = state.modeProgress[mode].timePerQuestion;
            state.feedback = null;
            render();
            startTimer();
        }

        function startTimer() {
            if (timerId) clearInterval(timerId);
            timerId = setInterval(() => {
                if (!state.isPaused && !state.feedback && state.timeLeft > 0) {
                    const hasMandelbrot = state.currentTrial?.premises.some(p => 
                        p.stimulus1.startsWith('mandelbrot_') || p.stimulus2.startsWith('mandelbrot_')
                    ) || false;
                    const speedMultiplier = (state.useMandelbrot && hasMandelbrot) ? 5 : 1;
                    state.timeLeft = Math.max(0, state.timeLeft - (0.1 * speedMultiplier));
                    render();
                    
                    if (state.timeLeft <= 0) {
                        handleTimeout();
                    }
                }
            }, 100);
        }

        function handleTimeout() {
            state.score.missed++;
            state.feedback = 'missed';
            const mode = state.currentTrial.mode;
            const modeTime = state.modeProgress[mode].timePerQuestion;
            const entry = {
                trial: state.currentTrial,
                userAnswer: null,
                isCorrect: false,
                timestamp: Date.now(),
                timeUsed: modeTime,
                premiseCount: state.currentTrial.premises.length
            };
            state.history.push(entry);
            state.statsHistory.push({
                timestamp: Date.now(),
                timeUsed: modeTime,
                premiseCount: state.currentTrial.premises.length,
                isCorrect: false,
                mode: mode
            });
            
            state.recentAnswers.push(false);
            state.modeProgress[mode].recentAnswers.push(false);
            checkAutoProgress(mode);
            
            render();
            saveToStorage();
            setTimeout(() => startNewTrial(), 1500);
        }

        function handleAnswer(userAnswer) {
            if (state.isPaused || state.feedback) return;
            
            const isCorrect = userAnswer === state.currentTrial.correctAnswer;
            const mode = state.currentTrial.mode;
            const modeTime = state.modeProgress[mode].timePerQuestion;
            const timeUsed = modeTime - state.timeLeft;
            
            if (isCorrect) {
                state.score.correct++;
            } else {
                state.score.incorrect++;
            }
            
            state.feedback = isCorrect ? 'correct' : 'incorrect';
            
            const entry = {
                trial: state.currentTrial,
                userAnswer,
                isCorrect,
                timestamp: Date.now(),
                timeUsed,
                premiseCount: state.currentTrial.premises.length
            };
            
            state.history.push(entry);
            state.statsHistory.push({
                timestamp: Date.now(),
                timeUsed,
                premiseCount: state.currentTrial.premises.length,
                isCorrect,
                mode: mode
            });
            
            state.recentAnswers.push(isCorrect);
            state.modeProgress[mode].recentAnswers.push(isCorrect);
            checkAutoProgress(mode);
            
            render();
            saveToStorage();
            setTimeout(() => startNewTrial(), 1500);
        }

        function checkAutoProgress(mode) {
            if (!state.autoProgressEnabled) return;
            
            if (state.universalAutoProgress) {
                if (state.recentAnswers.length < state.targetPremiseCount) return;
                
                const recentWindow = state.recentAnswers.slice(-state.targetPremiseCount);
                const accuracy = (recentWindow.filter(a => a).length / state.targetPremiseCount) * 100;
                
                if (accuracy >= state.targetAccuracy) {
                    if (state.timePerQuestion > 10) {
                        state.timePerQuestion = Math.max(10, state.timePerQuestion - 5);
                        Object.keys(state.modeProgress).forEach(m => {
                            state.modeProgress[m].timePerQuestion = state.timePerQuestion;
                        });
                        state.recentAnswers = [];
                    } else {
                        Object.keys(state.premiseCounts).forEach(m => {
                            state.premiseCounts[m] = Math.min(100, state.premiseCounts[m] + 1);
                        });
                        state.timePerQuestion = 30;
                        Object.keys(state.modeProgress).forEach(m => {
                            state.modeProgress[m].timePerQuestion = 30;
                        });
                        state.recentAnswers = [];
                    }
                }
            } else {
                const modeData = state.modeProgress[mode];
                if (modeData.recentAnswers.length < state.targetPremiseCount) return;
                
                const recentWindow = modeData.recentAnswers.slice(-state.targetPremiseCount);
                const accuracy = (recentWindow.filter(a => a).length / state.targetPremiseCount) * 100;
                
                if (accuracy >= state.targetAccuracy) {
                    if (modeData.timePerQuestion > 10) {
                        modeData.timePerQuestion = Math.max(10, modeData.timePerQuestion - 5);
                        modeData.recentAnswers = [];
                    } else {
                        state.premiseCounts[mode] = Math.min(100, state.premiseCounts[mode] + 1);
                        modeData.timePerQuestion = 30;
                        modeData.recentAnswers = [];
                    }
                }
            }
        }

        function togglePause() {
            state.isPaused = !state.isPaused;
            if (!state.isPaused) {
                state.currentTrial = generateTrial();
                const mode = state.currentTrial.mode;
                state.timeLeft = state.modeProgress[mode].timePerQuestion;
                state.feedback = null;
                startTimer();
            } else {
                if (state.currentTrial) {
                    const mode = state.currentTrial.mode;
                    state.timeLeft = state.modeProgress[mode].timePerQuestion;
                }
            }
            render();
        }

        function resetGame() {
            state.score = { correct: 0, incorrect: 0, missed: 0 };
            state.history = [];
            state.recentAnswers = [];
            state.statsHistory = [];
            state.modeProgress = {
                equality: { recentAnswers: [], timePerQuestion: 30 },
                temporal: { recentAnswers: [], timePerQuestion: 30 },
                spatial: { recentAnswers: [], timePerQuestion: 30 },
                containment: { recentAnswers: [], timePerQuestion: 30 }
            };
            saveToStorage();
            startNewTrial();
        }

        function getAnswerLabel(answer) {
            if (answer === true) return 'YES';
            if (answer === false) return 'NO';
            if (answer === 'ambiguous') return "CAN'T TELL";
            return 'NO ANSWER';
        }

        function getRelationColor(relation) {
            const colors = {
                dark: {
                    'SAME': 'bg-green-900/40 text-green-300 border-green-500',
                    'OPPOSITE': 'bg-red-900/40 text-red-300 border-red-500',
                    'DIFFERENT': 'bg-blue-900/40 text-blue-300 border-blue-500',
                    'BEFORE': 'bg-purple-900/40 text-purple-300 border-purple-500',
                    'AFTER': 'bg-orange-900/40 text-orange-300 border-orange-500',
                    'AT': 'bg-cyan-900/40 text-cyan-300 border-cyan-500',
                    'CONTAINS': 'bg-blue-900/40 text-blue-300 border-blue-500',
                    'WITHIN': 'bg-green-900/40 text-green-300 border-green-500',
                    'spatial': 'bg-teal-900/40 text-teal-300 border-teal-500'
                },
                light: {
                    'SAME': 'bg-green-100 text-green-700 border-green-300',
                    'OPPOSITE': 'bg-red-100 text-red-700 border-red-300',
                    'DIFFERENT': 'bg-blue-100 text-blue-700 border-blue-300',
                    'BEFORE': 'bg-purple-100 text-purple-700 border-purple-300',
                    'AFTER': 'bg-orange-100 text-orange-700 border-orange-300',
                    'AT': 'bg-cyan-100 text-cyan-700 border-cyan-300',
                    'CONTAINS': 'bg-blue-100 text-blue-700 border-blue-300',
                    'WITHIN': 'bg-green-100 text-green-700 border-green-300',
                    'spatial': 'bg-teal-100 text-teal-700 border-teal-300'
                }
            };
            
            const mode = state.darkMode ? 'dark' : 'light';
            if (['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'].includes(relation)) {
                return colors[mode]['spatial'];
            }
            return colors[mode][relation] || colors[mode]['SAME'];
        }

        function renderStimulus(stimulus) {
            if (stimulus.startsWith('voronoi_')) {
                const seed = parseInt(stimulus.split('_')[1]);
                return `<div class="w-16 h-16 flex items-center justify-center">${generateVoronoiSVG(seed)}</div>`;
            } else if (stimulus.startsWith('mandelbrot_')) {
                const seed = parseInt(stimulus.split('_')[1]);
                return `<div class="w-16 h-16 flex items-center justify-center">${generateMandelbrotSVG(seed)}</div>`;
            } else if (emojiList.includes(stimulus)) {
                return `<span class="emoji-stimulus">${stimulus}</span>`;
            } else {
                return `<span class="text-2xl font-bold">${stimulus}</span>`;
            }
        }

        function render() {
            const app = document.getElementById('app');
            const bgClass = state.darkMode ? 'bg-gray-900' : 'bg-gray-50';
            const textClass = state.darkMode ? 'text-gray-100' : 'text-gray-900';
            const cardClass = state.darkMode ? 'bg-gray-800 text-gray-100' : 'bg-white text-gray-900';
            
            if (state.isPaused) {
                app.innerHTML = `
                    <div class="${bgClass} ${textClass} min-h-screen flex items-center justify-center p-4">
                        <div class="${cardClass} rounded-lg shadow-xl p-8 max-w-md w-full text-center">
                            <h1 class="text-3xl font-bold mb-6">Paused</h1>
                            <div class="space-y-4 mb-8">
                                <div class="flex justify-between items-center p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded">
                                    <span>Correct:</span>
                                    <span class="text-green-500 font-bold text-xl">${state.score.correct}</span>
                                </div>
                                <div class="flex justify-between items-center p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded">
                                    <span>Incorrect:</span>
                                    <span class="text-red-500 font-bold text-xl">${state.score.incorrect}</span>
                                </div>
                                <div class="flex justify-between items-center p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded">
                                    <span>Missed:</span>
                                    <span class="text-yellow-500 font-bold text-xl">${state.score.missed}</span>
                                </div>
                            </div>
                            <div class="space-y-3">
                                <button onclick="togglePause()" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
                                    Resume
                                </button>
                                <button onclick="state.showSettings = true; render();" class="w-full ${state.darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300'} px-6 py-3 rounded-lg font-semibold transition-colors">
                                    Settings
                                </button>
                                <button onclick="state.showHistory = true; render();" class="w-full ${state.darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300'} px-6 py-3 rounded-lg font-semibold transition-colors">
                                    History
                                </button>
                                <button onclick="state.showStats = true; render();" class="w-full ${state.darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300'} px-6 py-3 rounded-lg font-semibold transition-colors">
                                    Statistics
                                </button>
                                <button onclick="if(confirm('Reset all progress?')) resetGame();" class="w-full bg-red-500 hover:bg-red-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
                                    Reset Progress
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            if (state.showSettings) {
                app.innerHTML = `
                    <div class="${bgClass} ${textClass} min-h-screen p-4 overflow-y-auto">
                        <div class="max-w-2xl mx-auto ${cardClass} rounded-lg shadow-xl p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-2xl font-bold">Settings</h2>
                                <button onclick="state.showSettings = false; render();" class="text-2xl">&times;</button>
                            </div>
                            
                            <div class="space-y-6">
                                <div>
                                    <label class="block mb-2 font-semibold">Dark Mode</label>
                                    <label class="flex items-center cursor-pointer">
                                        <input type="checkbox" ${state.darkMode ? 'checked' : ''} onchange="state.darkMode = this.checked; render();" class="mr-2">
                                        <span>Enable dark mode</span>
                                    </label>
                                </div>

                                <div>
                                    <label class="block mb-2 font-semibold">Stimulus Types</label>
                                    <div class="space-y-2">
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.useLetters ? 'checked' : ''} onchange="state.useLetters = this.checked; render();" class="mr-2">
                                            <span>Letters</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.useEmojis ? 'checked' : ''} onchange="state.useEmojis = this.checked; render();" class="mr-2">
                                            <span>Emojis</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.useVoronoi ? 'checked' : ''} onchange="state.useVoronoi = this.checked; render();" class="mr-2">
                                            <span>Voronoi Patterns</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.useMandelbrot ? 'checked' : ''} onchange="state.useMandelbrot = this.checked; render();" class="mr-2">
                                            <span>Mandelbrot Fractals</span>
                                        </label>
                                    </div>
                                </div>

                                <div>
                                    <label class="block mb-2 font-semibold">Letter Length: ${state.letterLength}</label>
                                    <input type="range" min="1" max="5" value="${state.letterLength}" 
                                        oninput="state.letterLength = parseInt(this.value); render();" 
                                        class="w-full">
                                </div>

                                <div>
                                    <label class="block mb-2 font-semibold">Network Complexity: ${Math.round(state.networkComplexity * 100)}%</label>
                                    <input type="range" min="0" max="100" value="${state.networkComplexity * 100}" 
                                        oninput="state.networkComplexity = parseInt(this.value) / 100; render();" 
                                        class="w-full">
                                </div>

                                <div>
                                    <label class="block mb-2 font-semibold">Relation Modes</label>
                                    <div class="space-y-2">
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.enabledRelationModes.equality ? 'checked' : ''} 
                                                onchange="state.enabledRelationModes.equality = this.checked; render();" class="mr-2">
                                            <span>Equality (SAME, OPPOSITE, DIFFERENT)</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.enabledRelationModes.temporal ? 'checked' : ''} 
                                                onchange="state.enabledRelationModes.temporal = this.checked; render();" class="mr-2">
                                            <span>Temporal (BEFORE, AFTER, AT)</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.enabledRelationModes.spatial ? 'checked' : ''} 
                                                onchange="state.enabledRelationModes.spatial = this.checked; render();" class="mr-2">
                                            <span>Spatial (NORTH, SOUTH, EAST, WEST...)</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.enabledRelationModes.containment ? 'checked' : ''} 
                                                onchange="state.enabledRelationModes.containment = this.checked; render();" class="mr-2">
                                            <span>Containment (CONTAINS, WITHIN)</span>
                                        </label>
                                    </div>
                                </div>

                                <div>
                                    <label class="block mb-2 font-semibold">Auto-Progress</label>
                                    <label class="flex items-center cursor-pointer">
                                        <input type="checkbox" ${state.autoProgressEnabled ? 'checked' : ''} 
                                            onchange="state.autoProgressEnabled = this.checked; render();" class="mr-2">
                                        <span>Enable automatic difficulty adjustment</span>
                                    </label>
                                </div>

                                ${state.autoProgressEnabled ? `
                                <div>
                                    <label class="block mb-2 font-semibold">Target Accuracy: ${state.targetAccuracy}%</label>
                                    <input type="range" min="50" max="100" value="${state.targetAccuracy}" 
                                        oninput="state.targetAccuracy = parseInt(this.value); render();" 
                                        class="w-full">
                                </div>

                                <div>
                                    <label class="block mb-2 font-semibold">Sample Size: ${state.targetPremiseCount} trials</label>
                                    <input type="range" min="10" max="100" value="${state.targetPremiseCount}" 
                                        oninput="state.targetPremiseCount = parseInt(this.value); render();" 
                                        class="w-full">
                                </div>
                                ` : ''}
                            </div>

                            <button onclick="state.showSettings = false; render();" 
                                class="mt-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
                                Done
                            </button>
                        </div>
                    </div>
                `;
                return;
            }

            if (state.showHistory) {
                const recentHistory = state.history.slice(-20).reverse();
                app.innerHTML = `
                    <div class="${bgClass} ${textClass} min-h-screen p-4 overflow-y-auto">
                        <div class="max-w-4xl mx-auto ${cardClass} rounded-lg shadow-xl p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-2xl font-bold">Recent History</h2>
                                <button onclick="state.showHistory = false; render();" class="text-2xl">&times;</button>
                            </div>
                            
                            ${recentHistory.length === 0 ? `
                                <p class="text-center py-8 ${state.darkMode ? 'text-gray-400' : 'text-gray-500'}">No history yet</p>
                            ` : `
                                <div class="space-y-4">
                                    ${recentHistory.map(entry => `
                                        <div class="p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded-lg">
                                            <div class="flex justify-between items-start mb-2">
                                                <span class="${entry.isCorrect ? 'text-green-500' : 'text-red-500'} font-bold">
                                                    ${entry.isCorrect ? 'âœ“ Correct' : 'âœ— Incorrect'}
                                                </span>
                                                <span class="text-sm ${state.darkMode ? 'text-gray-400' : 'text-gray-500'}">
                                                    ${new Date(entry.timestamp).toLocaleTimeString()}
                                                </span>
                                            </div>
                                            <div class="text-sm">
                                                <p>Premises: ${entry.premiseCount}</p>
                                                <p>Time: ${entry.timeUsed.toFixed(1)}s</p>
                                                <p>Your answer: ${getAnswerLabel(entry.userAnswer)}</p>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            `}

                            <button onclick="state.showHistory = false; render();" 
                                class="mt-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
                                Close
                            </button>
                        </div>
                    </div>
                `;
                return;
            }

            if (state.showStats) {
                const total = state.score.correct + state.score.incorrect + state.score.missed;
                const accuracy = total > 0 ? ((state.score.correct / total) * 100).toFixed(1) : 0;
                const avgTime = state.statsHistory.length > 0 
                    ? (state.statsHistory.reduce((sum, s) => sum + s.timeUsed, 0) / state.statsHistory.length).toFixed(1)
                    : 0;

                app.innerHTML = `
                    <div class="${bgClass} ${textClass} min-h-screen p-4 overflow-y-auto">
                        <div class="max-w-2xl mx-auto ${cardClass} rounded-lg shadow-xl p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-2xl font-bold">Statistics</h2>
                                <button onclick="state.showStats = false; render();" class="text-2xl">&times;</button>
                            </div>
                            
                            <div class="space-y-4">
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded-lg text-center">
                                        <div class="text-3xl font-bold text-green-500">${state.score.correct}</div>
                                        <div class="text-sm">Correct</div>
                                    </div>
                                    <div class="p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded-lg text-center">
                                        <div class="text-3xl font-bold text-red-500">${state.score.incorrect}</div>
                                        <div class="text-sm">Incorrect</div>
                                    </div>
                                    <div class="p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded-lg text-center">
                                        <div class="text-3xl font-bold text-yellow-500">${state.score.missed}</div>
                                        <div class="text-sm">Missed</div>
                                    </div>
                                    <div class="p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded-lg text-center">
                                        <div class="text-3xl font-bold text-indigo-500">${total}</div>
                                        <div class="text-sm">Total</div>
                                    </div>
                                </div>

                                <div class="p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded-lg">
                                    <div class="flex justify-between mb-2">
                                        <span>Accuracy:</span>
                                        <span class="font-bold text-indigo-500">${accuracy}%</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span>Avg Response Time:</span>
                                        <span class="font-bold">${avgTime}s</span>
                                    </div>
                                </div>
                            </div>

                            <button onclick="state.showStats = false; render();" 
                                class="mt-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
                                Close
                            </button>
                        </div>
                    </div>
                `;
                return;
            }

            if (!state.currentTrial) {
                app.innerHTML = `
                    <div class="${bgClass} ${textClass} min-h-screen flex items-center justify-center">
                        <div class="text-center">
                            <div class="animate-spin rounded-full h-16 w-16 border-b-2 border-indigo-500 mx-auto"></div>
                            <p class="mt-4">Loading...</p>
                        </div>
                    </div>
                `;
                return;
            }

            const trial = state.currentTrial;
            const progressPercent = (state.timeLeft / state.modeProgress[trial.mode].timePerQuestion) * 100;
            let progressColor = 'bg-green-500';
            if (progressPercent < 33) progressColor = 'bg-red-500';
            else if (progressPercent < 66) progressColor = 'bg-yellow-500';

            app.innerHTML = `
                <div class="${bgClass} ${textClass} min-h-screen flex flex-col">
                    <!-- Header -->
                    <div class="${cardClass} shadow-md p-4">
                        <div class="max-w-4xl mx-auto flex justify-between items-center">
                            <button onclick="togglePause()" class="px-4 py-2 ${state.darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300'} rounded-lg transition-colors">
                                â¸ Pause
                            </button>
                            <div class="flex gap-4 text-sm">
                                <span class="text-green-500 font-bold">âœ“ ${state.score.correct}</span>
                                <span class="text-red-500 font-bold">âœ— ${state.score.incorrect}</span>
                                <span class="text-yellow-500 font-bold">âŠ— ${state.score.missed}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Main Content -->
                    <div class="flex-1 flex items-center justify-center p-4 overflow-y-auto">
                        <div class="max-w-4xl w-full">
                            <!-- Timer -->
                            <div class="mb-6">
                                <div class="h-2 bg-gray-300 dark:bg-gray-700 rounded-full overflow-hidden">
                                    <div class="${progressColor} h-full transition-all duration-100" style="width: ${progressPercent}%"></div>
                                </div>
                                <div class="text-center mt-2 text-sm font-mono">${state.timeLeft.toFixed(1)}s</div>
                            </div>

                            <!-- Premises -->
                            <div class="${cardClass} rounded-lg shadow-lg p-6 mb-6">
                                <h3 class="text-lg font-semibold mb-4">Given Information:</h3>
                                <div class="space-y-3">
                                    ${trial.premises.map((premise, idx) => `
                                        <div class="flex items-center justify-center gap-4 p-3 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded-lg">
                                            <div class="flex items-center justify-center">
                                                ${renderStimulus(premise.stimulus1)}
                                            </div>
                                            <div class="px-4 py-2 ${getRelationColor(premise.relation)} border-2 rounded-lg font-semibold text-sm">
                                                ${premise.relation}
                                            </div>
                                            <div class="flex items-center justify-center">
                                                ${renderStimulus(premise.stimulus2)}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Question -->
                            <div class="${cardClass} rounded-lg shadow-lg p-6 mb-6">
                                <h3 class="text-lg font-semibold mb-4">Question:</h3>
                                <div class="flex items-center justify-center gap-4 p-4 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-100'} rounded-lg">
                                    <div class="flex items-center justify-center">
                                        ${renderStimulus(trial.question.stimulus1)}
                                    </div>
                                    <div class="px-4 py-2 ${getRelationColor(trial.question.relation)} border-2 rounded-lg font-semibold text-sm">
                                        ${trial.question.relation}
                                    </div>
                                    <div class="flex items-center justify-center">
                                        ${renderStimulus(trial.question.stimulus2)}
                                    </div>
                                </div>
                                <p class="text-center mt-4 text-lg">Is this relationship true?</p>
                            </div>

                            <!-- Answer Buttons -->
                            <div class="grid grid-cols-3 gap-4">
                                <button onclick="handleAnswer(true)" 
                                    ${state.feedback ? 'disabled' : ''}
                                    class="py-4 bg-green-500 hover:bg-green-600 disabled:opacity-50 text-white rounded-lg font-bold text-lg transition-colors">
                                    YES
                                </button>
                                <button onclick="handleAnswer(false)" 
                                    ${state.feedback ? 'disabled' : ''}
                                    class="py-4 bg-red-500 hover:bg-red-600 disabled:opacity-50 text-white rounded-lg font-bold text-lg transition-colors">
                                    NO
                                </button>
                                <button onclick="handleAnswer('ambiguous')" 
                                    ${state.feedback ? 'disabled' : ''}
                                    class="py-4 bg-yellow-500 hover:bg-yellow-600 disabled:opacity-50 text-white rounded-lg font-bold text-lg transition-colors">
                                    CAN'T TELL
                                </button>
                            </div>

                            <!-- Feedback -->
                            ${state.feedback ? `
                                <div class="mt-6 p-4 rounded-lg text-center font-bold text-lg ${
                                    state.feedback === 'correct' ? 'bg-green-500 text-white' :
                                    state.feedback === 'incorrect' ? 'bg-red-500 text-white' :
                                    'bg-yellow-500 text-white'
                                }">
                                    ${state.feedback === 'correct' ? 'âœ“ Correct!' : 
                                      state.feedback === 'incorrect' ? 'âœ— Incorrect' : 
                                      'âŠ— Time\'s up!'}
                                    ${state.feedback !== 'correct' ? `<div class="text-sm mt-2">Correct answer: ${getAnswerLabel(trial.correctAnswer)}</div>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        // Initialize
        loadFromStorage();
        if (state.darkMode) {
            document.body.classList.add('dark');
        }
        startNewTrial();
    </script>
</body>
</html>
