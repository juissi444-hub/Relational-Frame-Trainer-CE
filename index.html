<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Relational Frame Trainer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .smooth-transition { transition: all 0.3s ease; }
    input[type="range"] { accent-color: rgb(79, 70, 229); }
  </style>
</head>
<body class="m-0 p-0 overflow-hidden">
  <div id="app"></div>

  <script>
    // State management
    const state = {
      difficulty: 3,
      timePerQuestion: 30,
      networkComplexity: 0.5,
      spoilerPremises: false,
      darkMode: false,
      useLetters: true,
      useEmojis: false,
      useVoronoi: false,
      letterLength: 3,
      autoProgressEnabled: true,
      targetPremiseCount: 40,
      targetAccuracy: 95,
      recentAnswers: [],
      statsHistory: [],
      showSettings: false,
      showHistory: false,
      showStats: false,
      showTutorial: false,
      isPaused: false,
      currentTrial: null,
      timeLeft: 30,
      score: { correct: 0, incorrect: 0, missed: 0 },
      feedback: null,
      history: [],
      hoveredPremise: null,
      enabledRelationModes: {
        equality: true,
        temporal: false,
        spatial: false,
        containment: false
      }
    };

    const relationSets = {
      equality: ['SAME', 'OPPOSITE', 'DIFFERENT'],
      temporal: ['BEFORE', 'AFTER', 'AT'],
      spatial: ['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'],
      containment: ['CONTAINS', 'WITHIN']
    };

    const emojiList = ['ğŸŒŸ', 'ğŸ¨', 'ğŸ­', 'ğŸª', 'ğŸ¯', 'ğŸ²', 'ğŸ¸', 'ğŸ¹', 'ğŸº', 'ğŸ»', 'ğŸŒˆ', 'ğŸŒŠ', 'ğŸŒ™', 'â­', 'ğŸ”¥', 'ğŸ’', 'ğŸŒ¸', 'ğŸŒº', 'ğŸŒ»', 'ğŸŒ¼', 'ğŸ€', 'ğŸ', 'ğŸ‚', 'ğŸƒ', 'ğŸˆ', 'ğŸ‰', 'ğŸŠ', 'ğŸ', 'ğŸ†', 'âš¡', 'ğŸ’«', 'âœ¨', 'ğŸŒ ', 'ğŸ”®', 'ğŸ’', 'ğŸ€', 'ğŸŒ¹', 'ğŸ¦‹', 'ğŸ', 'ğŸ', 'ğŸ¦„', 'ğŸ‰', 'ğŸ¦Š', 'ğŸº', 'ğŸ¦', 'ğŸ¯', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¸', 'ğŸ¦‰', 'ğŸ¦…', 'ğŸ¦†', 'ğŸ¦¢', 'ğŸ§', 'ğŸ™', 'ğŸ¦‘', 'ğŸ¦€', 'ğŸ ', 'ğŸ¡', 'ğŸ¬', 'ğŸ³', 'ğŸ¦ˆ', 'ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ«', 'ğŸ’', 'ğŸ‘', 'ğŸ¥­', 'ğŸ', 'ğŸ¥¥', 'ğŸ¥'];

    let timerInterval = null;

    // Icons as SVG
    const icons = {
      settings: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6"></path></svg>',
      history: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path><path d="M12 7v5l4 2"></path></svg>',
      play: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>',
      pause: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>',
      reset: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path></svg>',
      x: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
      check: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>',
      clock: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>',
      trending: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline></svg>',
      info: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>'
    };

    // Helper functions
    const generateVoronoiSVG = (seed) => {
      const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
      const random = (s) => { const x = Math.sin(s++) * 10000; return x - Math.floor(x); };
      const points = [];
      for (let i = 0; i < 8; i++) {
        points.push({ x: random(seed + i) * 100, y: random(seed + i + 100) * 100, color: colors[i % colors.length] });
      }
      return '<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">' + points.map((p, i) => '<circle cx="' + p.x + '" cy="' + p.y + '" r="' + (15 + random(seed + i + 200) * 10) + '" fill="' + p.color + '" opacity="0.7" />').join('') + '</svg>';
    };

    const generateStimulus = () => {
      const availableTypes = [];
      if (state.useLetters) availableTypes.push('letters');
      if (state.useEmojis) availableTypes.push('emojis');
      if (state.useVoronoi) availableTypes.push('voronoi');
      
      if (availableTypes.length === 0) availableTypes.push('letters');
      
      const selectedType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      
      if (selectedType === 'emojis') {
        return emojiList[Math.floor(Math.random() * emojiList.length)];
      } else if (selectedType === 'voronoi') {
        return 'voronoi_' + Math.floor(Math.random() * 1000000);
      } else {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let result = '';
        for (let i = 0; i < state.letterLength; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
        return result;
      }
    };

    const getRelationMode = (relation) => {
      if (['SAME', 'OPPOSITE', 'DIFFERENT'].includes(relation)) return 'equality';
      if (['BEFORE', 'AFTER', 'AT'].includes(relation)) return 'temporal';
      if (['CONTAINS', 'WITHIN'].includes(relation)) return 'containment';
      return 'spatial';
    };

    const deriveRelation = (rel1, rel2) => {
      const mode1 = getRelationMode(rel1);
      const mode2 = getRelationMode(rel2);
      
      if (mode1 !== mode2) return 'AMBIGUOUS';
      
      if (mode1 === 'equality') {
        if (rel1 === 'SAME') return rel2;
        if (rel2 === 'SAME') return rel1;
        if (rel1 === 'OPPOSITE' && rel2 === 'OPPOSITE') return 'SAME';
        if (rel1 === 'OPPOSITE' && rel2 === 'DIFFERENT') return 'DIFFERENT';
        if (rel1 === 'DIFFERENT' && rel2 === 'OPPOSITE') return 'DIFFERENT';
        if (rel1 === 'DIFFERENT' && rel2 === 'DIFFERENT') return 'AMBIGUOUS';
        return 'AMBIGUOUS';
      } else if (mode1 === 'temporal') {
        if (rel1 === 'AT') return rel2;
        if (rel2 === 'AT') return rel1;
        if (rel1 === 'BEFORE' && rel2 === 'BEFORE') return 'BEFORE';
        if (rel1 === 'AFTER' && rel2 === 'AFTER') return 'AFTER';
        if (rel1 === 'BEFORE' && rel2 === 'AFTER') return 'AMBIGUOUS';
        if (rel1 === 'AFTER' && rel2 === 'BEFORE') return 'AMBIGUOUS';
        return 'AMBIGUOUS';
      } else if (mode1 === 'containment') {
        if (rel1 === 'CONTAINS' && rel2 === 'CONTAINS') return 'CONTAINS';
        if (rel1 === 'WITHIN' && rel2 === 'WITHIN') return 'WITHIN';
        if (rel1 === 'CONTAINS' && rel2 === 'WITHIN') return 'AMBIGUOUS';
        if (rel1 === 'WITHIN' && rel2 === 'CONTAINS') return 'AMBIGUOUS';
        return 'AMBIGUOUS';
      } else {
        const opposites = {
          'NORTH': 'SOUTH', 'SOUTH': 'NORTH',
          'EAST': 'WEST', 'WEST': 'EAST',
          'NORTHEAST': 'SOUTHWEST', 'SOUTHWEST': 'NORTHEAST',
          'NORTHWEST': 'SOUTHEAST', 'SOUTHEAST': 'NORTHWEST'
        };
        
        if (rel1 === rel2) return rel1;
        if (opposites[rel1] === rel2) return 'AMBIGUOUS';
        
        return 'AMBIGUOUS';
      }
    };

    const findAllPaths = (graph, start, end, currentPath = [], visited = new Set(), allPaths = []) => {
      if (start === end && currentPath.length > 0) {
        allPaths.push([...currentPath]);
        return allPaths;
      }
      visited.add(start);
      for (const edge of graph) {
        let nextNode = null, edgeToAdd = null;
        if (edge.stimulus1 === start && !visited.has(edge.stimulus2)) {
          nextNode = edge.stimulus2;
          edgeToAdd = { ...edge, reversed: false };
        } else if (edge.stimulus2 === start && !visited.has(edge.stimulus1)) {
          nextNode = edge.stimulus1;
          edgeToAdd = { ...edge, reversed: true };
        }
        if (nextNode) {
          currentPath.push(edgeToAdd);
          findAllPaths(graph, nextNode, end, currentPath, new Set(visited), allPaths);
          currentPath.pop();
        }
      }
      return allPaths;
    };

    const deriveFromPath = (path) => {
      if (!path || path.length === 0) return null;
      let result = path[0].relation;
      for (let i = 1; i < path.length; i++) {
        result = deriveRelation(result, path[i].relation);
        if (result === 'AMBIGUOUS') return 'AMBIGUOUS';
      }
      return result;
    };

    const deriveRelationFromGraph = (graph, start, end) => {
      if (start === end) {
        if (state.enabledRelationModes.equality) return 'SAME';
        if (state.enabledRelationModes.temporal) return 'AT';
        return null;
      }
      const allPaths = findAllPaths(graph, start, end);
      if (allPaths.length === 0) return null;
      
      const derivedRelations = allPaths.map(path => deriveFromPath(path)).filter(r => r !== null);
      if (derivedRelations.length === 0) return null;
      
      const nonAmbiguous = derivedRelations.filter(r => r !== 'AMBIGUOUS');
      if (nonAmbiguous.length === 0) return 'AMBIGUOUS';
      
      const firstRel = nonAmbiguous[0];
      const allAgree = nonAmbiguous.every(rel => rel === firstRel);
      
      return allAgree ? firstRel : 'AMBIGUOUS';
    };

    const generateTrial = () => {
      const enabledModes = Object.keys(state.enabledRelationModes).filter(mode => state.enabledRelationModes[mode]);
      const chosenMode = enabledModes.length > 0 
        ? enabledModes[Math.floor(Math.random() * enabledModes.length)]
        : 'equality';
      const activeRelations = relationSets[chosenMode];
      
      const numStimuli = Math.max(3, state.difficulty + 1);
      const stimuli = [generateStimulus()];
      const premises = [];
      
      for (let p = 0; p < state.difficulty; p++) {
        let chosenPair = null;
        const ambiguousPairs = [];
        for (let i = 0; i < stimuli.length; i++) {
          for (let j = i + 1; j < stimuli.length; j++) {
            const s1 = stimuli[i], s2 = stimuli[j];
            const alreadyConnected = premises.some(pr => (pr.stimulus1 === s1 && pr.stimulus2 === s2) || (pr.stimulus1 === s2 && pr.stimulus2 === s1));
            if (!alreadyConnected) {
              const derived = deriveRelationFromGraph(premises, s1, s2);
              if (derived === 'AMBIGUOUS') ambiguousPairs.push({ s1, s2 });
            }
          }
        }
        if (ambiguousPairs.length > 0 && Math.random() < state.networkComplexity) {
          chosenPair = ambiguousPairs[Math.floor(Math.random() * ambiguousPairs.length)];
        } else if (stimuli.length < numStimuli) {
          const newStimulus = generateStimulus();
          stimuli.push(newStimulus);
          chosenPair = { s1: stimuli[Math.floor(Math.random() * (stimuli.length - 1))], s2: newStimulus };
        } else {
          const availablePairs = [];
          for (let i = 0; i < stimuli.length; i++) {
            for (let j = i + 1; j < stimuli.length; j++) {
              const s1 = stimuli[i], s2 = stimuli[j];
              if (!premises.some(pr => (pr.stimulus1 === s1 && pr.stimulus2 === s2) || (pr.stimulus1 === s2 && pr.stimulus2 === s1))) {
                availablePairs.push({ s1, s2 });
              }
            }
          }
          chosenPair = availablePairs.length > 0 ? availablePairs[Math.floor(Math.random() * availablePairs.length)] : { s1: stimuli[0], s2: stimuli[1] };
        }
        if (chosenPair) premises.push({ stimulus1: chosenPair.s1, relation: activeRelations[Math.floor(Math.random() * activeRelations.length)], stimulus2: chosenPair.s2 });
      }
      
      const startIdx = Math.floor(Math.random() * stimuli.length);
      let endIdx = Math.floor(Math.random() * stimuli.length);
      if (startIdx === endIdx) endIdx = (endIdx + 1) % stimuli.length;
      const derivedRelation = deriveRelationFromGraph(premises, stimuli[startIdx], stimuli[endIdx]);
      let questionRelation, correctAnswer;
      
      if (derivedRelation === 'AMBIGUOUS' || derivedRelation === null) {
        questionRelation = activeRelations[Math.floor(Math.random() * activeRelations.length)];
        correctAnswer = 'ambiguous';
      } else {
        const askCompatible = Math.random() < 0.5;
        if (askCompatible) {
          questionRelation = derivedRelation;
          correctAnswer = true;
        } else {
          const incompatible = activeRelations.filter(r => r !== derivedRelation);
          if (incompatible.length > 0) {
            questionRelation = incompatible[Math.floor(Math.random() * incompatible.length)];
            correctAnswer = false;
          } else {
            questionRelation = derivedRelation;
            correctAnswer = true;
          }
        }
      }

      return { 
        premises, 
        question: { stimulus1: stimuli[startIdx], relation: questionRelation, stimulus2: stimuli[endIdx] }, 
        correctAnswer, 
        derivedRelation: derivedRelation || 'AMBIGUOUS', 
        allPaths: findAllPaths(premises, stimuli[startIdx], stimuli[endIdx]), 
        allStimuli: stimuli 
      };
    };

    const startNewTrial = () => {
      state.currentTrial = generateTrial();
      state.timeLeft = state.timePerQuestion;
      state.feedback = null;
      render();
    };

    const saveToStorage = async () => {
      try {
        await window.storage.set('rft-data', JSON.stringify({ 
          score: state.score, 
          history: state.history, 
          statsHistory: state.statsHistory, 
          settings: { 
            difficulty: state.difficulty, 
            timePerQuestion: state.timePerQuestion, 
            networkComplexity: state.networkComplexity, 
            spoilerPremises: state.spoilerPremises, 
            darkMode: state.darkMode, 
            useLetters: state.useLetters, 
            useEmojis: state.useEmojis, 
            useVoronoi: state.useVoronoi, 
            letterLength: state.letterLength, 
            autoProgressEnabled: state.autoProgressEnabled, 
            targetPremiseCount: state.targetPremiseCount, 
            targetAccuracy: state.targetAccuracy, 
            enabledRelationModes: state.enabledRelationModes 
          }, 
          recentAnswers: state.recentAnswers 
        }));
      } catch (error) {
        console.error('Save failed:', error);
      }
    };

    const loadFromStorage = async () => {
      try {
        const result = await window.storage.get('rft-data');
        if (result && result.value) {
          const data = JSON.parse(result.value);
          if (data.score) state.score = data.score;
          if (data.history) state.history = data.history;
          if (data.statsHistory) state.statsHistory = data.statsHistory;
          if (data.recentAnswers) state.recentAnswers = data.recentAnswers;
          if (data.settings) {
            Object.assign(state, data.settings);
          }
        }
      } catch (error) {
        console.log('No saved data found');
      }
    };

    const resetGame = () => {
      state.score = { correct: 0, incorrect: 0, missed: 0 };
      state.history = [];
      state.recentAnswers = [];
      state.statsHistory = [];
      startNewTrial();
      saveToStorage();
    };

    const getAnswerLabel = (answer) => {
      if (answer === true) return 'YES';
      if (answer === false) return 'NO';
      if (answer === 'ambiguous') return "CAN'T TELL";
      return 'NO ANSWER';
    };

    const checkAutoProgress = (updatedAnswers) => {
      if (!state.autoProgressEnabled || updatedAnswers.length < state.targetPremiseCount) return;
      const recentWindow = updatedAnswers.slice(-state.targetPremiseCount);
      const accuracy = (recentWindow.filter(a => a).length / state.targetPremiseCount) * 100;
      if (accuracy >= state.targetAccuracy) {
        if (state.timePerQuestion > 10) {
          const newTime = Math.max(10, state.timePerQuestion - 5);
          state.timePerQuestion = newTime;
          if (newTime === 10) {
            state.difficulty += 1;
            state.timePerQuestion = 30;
            state.recentAnswers = [];
          }
        } else {
          state.difficulty += 1;
          state.timePerQuestion = 30;
          state.recentAnswers = [];
        }
      }
    };

    const handleAnswer = (userAnswer) => {
      if (state.isPaused || state.feedback) return;
      const isCorrect = userAnswer === state.currentTrial.correctAnswer;
      const timeUsed = state.timePerQuestion - state.timeLeft;
      state.score.correct += isCorrect ? 1 : 0;
      state.score.incorrect += isCorrect ? 0 : 1;
      state.feedback = isCorrect ? 'correct' : 'incorrect';
      const entry = { 
        trial: state.currentTrial, 
        userAnswer, 
        isCorrect, 
        timestamp: Date.now(), 
        timeUsed, 
        premiseCount: state.currentTrial.premises.length 
      };
      state.history.push(entry);
      state.statsHistory.push({ 
        timestamp: Date.now(), 
        timeUsed, 
        premiseCount: state.currentTrial.premises.length, 
        isCorrect 
      });
      const updatedAnswers = [...state.recentAnswers, isCorrect];
      state.recentAnswers = updatedAnswers;
      checkAutoProgress(updatedAnswers);
      render();
      setTimeout(() => { 
        startNewTrial(); 
        saveToStorage(); 
      }, 1500);
    };

    const togglePause = () => {
      state.isPaused = !state.isPaused;
      if (!state.isPaused) {
        state.currentTrial = generateTrial();
        state.feedback = null;
      } else {
        state.timeLeft = state.timePerQuestion;
      }
      render();
    };

    const startTimer = () => {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (!state.isPaused && !state.feedback && state.timeLeft > 0) {
          state.timeLeft = Math.max(0, state.timeLeft - 0.1);
          const timerEl = document.querySelector('#timer-display');
          if (timerEl) timerEl.textContent = state.timeLeft.toFixed(1) + 's';
          const progressBar = document.querySelector('#progress-bar');
          if (progressBar) {
            progressBar.style.width = ((state.timeLeft / state.timePerQuestion) * 100) + '%';
          }
        } else if (!state.isPaused && !state.feedback && state.timeLeft <= 0) {
          const timeUsed = state.timePerQuestion;
          state.score.missed += 1;
          state.feedback = 'missed';
          state.history.push({ 
            trial: state.currentTrial, 
            userAnswer: null, 
            isCorrect: false, 
            timestamp: Date.now(), 
            timeUsed, 
            premiseCount: state.currentTrial.premises.length 
          });
          state.statsHistory.push({ 
            timestamp: Date.now(), 
            timeUsed, 
            premiseCount: state.currentTrial.premises.length, 
            isCorrect: false 
          });
          render();
          setTimeout(() => { 
            startNewTrial(); 
            saveToStorage(); 
          }, 1500);
        }
      }, 100);
    };

    const renderStimulus = (stimulus) => {
      if (stimulus.startsWith('voronoi_')) {
        return '<div class="inline-block w-16 h-16 align-middle">' + generateVoronoiSVG(parseInt(stimulus.split('_')[1])) + '</div>';
      }
      const isEmoji = emojiList.includes(stimulus);
      const textClass = isEmoji ? 'text-3xl' : '';
      const colorClass = state.darkMode ? 'text-indigo-400' : 'text-indigo-600';
      return '<span class="font-bold ' + textClass + ' ' + colorClass + '">' + stimulus + '</span>';
    };

    const getRelationColor = (relation) => {
      if (state.darkMode) {
        if (relation === 'SAME') return 'bg-green-900/40 text-green-300 border-green-500';
        if (relation === 'OPPOSITE') return 'bg-red-900/40 text-red-300 border-red-500';
        if (relation === 'DIFFERENT') return 'bg-blue-900/40 text-blue-300 border-blue-500';
        if (relation === 'BEFORE') return 'bg-purple-900/40 text-purple-300 border-purple-500';
        if (relation === 'AFTER') return 'bg-orange-900/40 text-orange-300 border-orange-500';
        if (relation === 'AT') return 'bg-cyan-900/40 text-cyan-300 border-cyan-500';
        if (['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'].includes(relation)) {
          return 'bg-teal-900/40 text-teal-300 border-teal-500';
        }
        return 'bg-blue-900/40 text-blue-300 border-blue-500';
      }
      
      if (relation === 'SAME') return 'bg-green-100 text-green-700 border-green-300';
      if (relation === 'OPPOSITE') return 'bg-red-100 text-red-700 border-red-300';
      if (relation === 'DIFFERENT') return 'bg-blue-100 text-blue-700 border-blue-300';
      if (relation === 'BEFORE') return 'bg-purple-100 text-purple-700 border-purple-300';
      if (relation === 'AFTER') return 'bg-orange-100 text-orange-700 border-orange-300';
      if (relation === 'AT') return 'bg-cyan-100 text-cyan-700 border-cyan-300';
      if (['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'].includes(relation)) {
        return 'bg-teal-100 text-teal-700 border-teal-300';
      }
      if (['CONTAINS', 'WITHIN'].includes(relation)) {
        return 'bg-amber-100 text-amber-700 border-amber-300';
      }
      return 'bg-blue-100 text-blue-700 border-blue-300';
    };

    // Render function
    const render = () => {
      const app = document.getElementById('app');
      const bgClass = state.darkMode ? 'bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900' : 'bg-gradient-to-br from-slate-50 to-slate-100';
      
      let html = '<div class="min-h-screen flex flex-col smooth-transition ' + bgClass + '">';
      
      // Tutorial Modal
      if (state.showTutorial) {
        html += '<div class="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4" onclick="handleBackdropClick(event, \'tutorial\')">';
        html += '<div class="max-w-2xl w-full rounded-2xl p-6 shadow-2xl max-h-[90vh] overflow-y-auto ' + (state.darkMode ? 'bg-slate-800' : 'bg-white') + '">';
        html += '<div class="flex justify-between items-center mb-4">';
        html += '<h2 class="text-2xl font-bold ' + (state.darkMode ? 'text-indigo-400' : 'text-indigo-600') + '">How to Play</h2>';
        html += '<button onclick="closeTutorial()" class="p-2 rounded-lg ' + (state.darkMode ? 'hover:bg-slate-700' : 'hover:bg-gray-100') + '">' + icons.x + '</button>';
        html += '</div>';
        html += '<div class="space-y-4 text-sm ' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '">';
        html += '<p><strong>Relational Frame Training</strong> helps you practice deriving logical relationships between stimuli.</p>';
        html += '<div><h3 class="font-bold mb-2">Game Rules:</h3><ul class="list-disc pl-6 space-y-2">';
        html += '<li>You will be given several <strong>premises</strong> that establish relationships between stimuli</li>';
        html += '<li>Based on these premises, you must answer whether a <strong>question relationship</strong> is true</li>';
        html += '<li>Answer <strong>YES</strong> if the relationship follows from the premises</li>';
        html += '<li>Answer <strong>NO</strong> if the relationship contradicts the premises</li>';
        html += '<li>Answer <strong>CAN\'T TELL</strong> if there is insufficient information or contradictions</li>';
        html += '</ul></div>';
        html += '<div><h3 class="font-bold mb-2">Keyboard Shortcuts:</h3><ul class="list-disc pl-6 space-y-2">';
        html += '<li><kbd class="px-2 py-1 rounded ' + (state.darkMode ? 'bg-slate-700' : 'bg-gray-200') + '">1</kbd> - Answer YES</li>';
        html += '<li><kbd class="px-2 py-1 rounded ' + (state.darkMode ? 'bg-slate-700' : 'bg-gray-200') + '">2</kbd> - Answer NO</li>';
        html += '<li><kbd class="px-2 py-1 rounded ' + (state.darkMode ? 'bg-slate-700' : 'bg-gray-200') + '">3</kbd> - Answer CAN\'T TELL</li>';
        html += '<li><kbd class="px-2 py-1 rounded ' + (state.darkMode ? 'bg-slate-700' : 'bg-gray-200') + '">Space</kbd> - Pause/Resume</li>';
        html += '</ul></div></div></div></div>';
      }

      // Backdrop for mobile panels
      if (state.showHistory || state.showStats) {
        html += '<div class="sm:hidden fixed inset-0 z-40 bg-black/50 backdrop-blur-sm" onclick="closeHistoryStats()"></div>';
      }

      // History Panel
      html += '<div class="smooth-transition overflow-hidden ' + (state.showHistory ? 'fixed sm:relative inset-y-0 left-0 w-[90vw] sm:w-96 z-50' : 'w-0') + ' ' + (state.darkMode ? 'bg-slate-800' : 'bg-white') + ' shadow-xl">';
      if (state.showHistory) {
        html += '<div class="h-full flex flex-col p-4">';
        html += '<div class="flex items-center justify-between mb-4">';
        html += '<div class="flex items-center"><span class="w-5 h-5 mr-2">' + icons.history + '</span><h2 class="text-lg font-bold ' + (state.darkMode ? 'text-gray-100' : 'text-gray-800') + '">History</h2></div>';
        html += '<button onclick="closeHistory()" class="p-1 rounded ' + (state.darkMode ? 'hover:bg-slate-700' : 'hover:bg-gray-100') + '">' + icons.x + '</button>';
        html += '</div>';
        html += '<div class="flex-1 overflow-y-auto space-y-3">';
        if (state.history.length === 0) {
          html += '<p class="text-sm ' + (state.darkMode ? 'text-gray-400' : 'text-gray-500') + '">No questions answered yet</p>';
        } else {
          state.history.slice().reverse().forEach((item, idx) => {
            const borderClass = state.darkMode ? (item.isCorrect ? 'border-green-500/50 bg-green-900/20' : 'border-red-500/50 bg-red-900/20') : (item.isCorrect ? 'border-green-300 bg-green-50' : 'border-red-300 bg-red-50');
            html += '<div class="p-3 rounded-lg border-2 ' + borderClass + '">';
            html += '<div class="text-xs font-semibold mb-2 ' + (state.darkMode ? 'text-gray-400' : 'text-gray-500') + '">Question #' + (state.history.length - idx) + ' â€¢ ' + item.timeUsed.toFixed(1) + 's</div>';
            html += '<div class="text-xs space-y-1">';
            const answerClass = item.isCorrect ? (state.darkMode ? 'text-green-400' : 'text-green-700') : (state.darkMode ? 'text-red-400' : 'text-red-700');
            html += '<div class="' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '"><span class="font-semibold">Your answer:</span> <span class="' + answerClass + '">' + getAnswerLabel(item.userAnswer) + '</span></div>';
            html += '<div class="' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '"><span class="font-semibold">Correct:</span> <span class="' + (state.darkMode ? 'text-green-400' : 'text-green-700') + '">' + getAnswerLabel(item.trial.correctAnswer) + '</span></div>';
            html += '</div></div>';
          });
        }
        html += '</div></div>';
      }
      html += '</div>';

      // Stats Panel
      html += '<div class="smooth-transition overflow-hidden ' + (state.showStats ? 'fixed sm:relative inset-y-0 left-0 w-[90vw] sm:w-96 z-50' : 'w-0') + ' ' + (state.darkMode ? 'bg-slate-800' : 'bg-white') + ' shadow-xl">';
      if (state.showStats) {
        html += '<div class="h-full flex flex-col p-4">';
        html += '<div class="flex items-center justify-between mb-4">';
        html += '<div class="flex items-center"><span class="w-5 h-5 mr-2">' + icons.trending + '</span><h2 class="text-lg font-bold ' + (state.darkMode ? 'text-gray-100' : 'text-gray-800') + '">Statistics</h2></div>';
        html += '<button onclick="closeStats()" class="p-1 rounded ' + (state.darkMode ? 'hover:bg-slate-700' : 'hover:bg-gray-100') + '">' + icons.x + '</button>';
        html += '</div>';
        html += '<div class="flex-1 overflow-y-auto space-y-6">';
        if (state.statsHistory.length === 0) {
          html += '<p class="text-sm ' + (state.darkMode ? 'text-gray-400' : 'text-gray-500') + '">No statistics yet</p>';
        } else {
          html += '<div class="p-4 rounded-lg ' + (state.darkMode ? 'bg-slate-700' : 'bg-gray-50') + '">';
          html += '<h3 class="text-sm font-semibold mb-3 ' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '">Overall</h3>';
          html += '<div class="space-y-2">';
          html += '<div class="flex justify-between"><span class="text-sm ' + (state.darkMode ? 'text-gray-400' : 'text-gray-600') + '">Total Questions:</span><span class="text-sm font-bold ' + (state.darkMode ? 'text-gray-200' : 'text-gray-800') + '">' + state.statsHistory.length + '</span></div>';
          const accuracy = ((state.statsHistory.filter(s => s.isCorrect).length / state.statsHistory.length) * 100).toFixed(1);
          html += '<div class="flex justify-between"><span class="text-sm ' + (state.darkMode ? 'text-gray-400' : 'text-gray-600') + '">Accuracy:</span><span class="text-sm font-bold ' + (state.darkMode ? 'text-green-400' : 'text-green-600') + '">' + accuracy + '%</span></div>';
          html += '</div></div>';
        }
        html += '</div></div>';
      }
      html += '</div>';

      // Main content
      html += '<div class="flex-1 flex flex-col min-h-0">';
      
      // Header
      html += '<div class="shadow-md p-3 flex flex-col gap-2 smooth-transition ' + (state.darkMode ? 'bg-slate-800/90 backdrop-blur' : 'bg-white') + '">';
      html += '<div class="flex justify-between items-center gap-2">';
      html += '<div class="flex gap-2">';
      html += '<button onclick="toggleHistory()" class="flex items-center gap-1 px-3 py-2 rounded-lg smooth-transition text-sm ' + (state.darkMode ? 'bg-indigo-900/50 hover:bg-indigo-900/70 text-indigo-200' : 'bg-indigo-100 hover:bg-indigo-200 text-gray-900') + '"><span class="w-4 h-4">' + icons.history + '</span><span class="hidden sm:inline">History</span></button>';
      html += '<button onclick="toggleStats()" class="flex items-center gap-1 px-3 py-2 rounded-lg smooth-transition text-sm ' + (state.darkMode ? 'bg-purple-900/50 hover:bg-purple-900/70 text-purple-200' : 'bg-purple-100 hover:bg-purple-200 text-gray-900') + '"><span class="w-4 h-4">' + icons.trending + '</span><span class="hidden sm:inline">Stats</span></button>';
      html += '<button onclick="toggleTutorial()" class="flex items-center gap-1 px-3 py-2 rounded-lg smooth-transition text-sm ' + (state.darkMode ? 'bg-cyan-900/50 hover:bg-cyan-900/70 text-cyan-200' : 'bg-cyan-100 hover:bg-cyan-200 text-gray-900') + '"><span class="w-4 h-4">' + icons.info + '</span><span class="hidden sm:inline">Help</span></button>';
      html += '</div>';
      html += '<div class="flex items-center gap-3">';
      html += '<div class="text-center"><div id="timer-display" class="text-xl font-bold tabular-nums ' + (state.darkMode ? 'text-indigo-400' : 'text-indigo-600') + '">' + state.timeLeft.toFixed(1) + 's</div><div class="text-xs hidden sm:block ' + (state.darkMode ? 'text-gray-400' : 'text-gray-600') + '">Time</div></div>';
      html += '<button onclick="togglePause()" class="text-white p-2 rounded-lg smooth-transition ' + (state.isPaused ? 'bg-green-500 hover:bg-green-600' : (state.darkMode ? 'bg-yellow-600 hover:bg-yellow-700' : 'bg-yellow-500 hover:bg-yellow-600')) + '"><span class="w-5 h-5 inline-block">' + (state.isPaused ? icons.play : icons.pause) + '</span></button>';
      html += '<button onclick="resetGame()" class="p-2 rounded-lg smooth-transition ' + (state.darkMode ? 'bg-slate-700 hover:bg-slate-600 text-gray-300' : 'bg-gray-200 hover:bg-gray-300') + '"><span class="w-5 h-5 inline-block">' + icons.reset + '</span></button>';
      html += '<button onclick="toggleSettings()" class="flex items-center gap-1 px-3 py-2 rounded-lg smooth-transition text-sm ' + (state.darkMode ? 'bg-indigo-900/50 hover:bg-indigo-900/70 text-indigo-200' : 'bg-indigo-100 hover:bg-indigo-200 text-gray-900') + '"><span class="w-4 h-4">' + icons.settings + '</span><span class="hidden sm:inline">Settings</span></button>';
      html += '</div></div>';
      
      // Score display
      html += '<div class="flex gap-4 justify-center sm:justify-start">';
      html += '<div class="text-center"><div class="text-xl font-bold ' + (state.darkMode ? 'text-green-400' : 'text-green-600') + '">' + state.score.correct + '</div><div class="text-xs ' + (state.darkMode ? 'text-gray-400' : 'text-gray-600') + '">Correct</div></div>';
      html += '<div class="text-center"><div class="text-xl font-bold ' + (state.darkMode ? 'text-red-400' : 'text-red-600') + '">' + state.score.incorrect + '</div><div class="text-xs ' + (state.darkMode ? 'text-gray-400' : 'text-gray-600') + '">Incorrect</div></div>';
      html += '<div class="text-center"><div class="text-xl font-bold ' + (state.darkMode ? 'text-orange-400' : 'text-orange-600') + '">' + state.score.missed + '</div><div class="text-xs ' + (state.darkMode ? 'text-gray-400' : 'text-gray-600') + '">Missed</div></div>';
      html += '</div></div>';

      // Progress bar
      html += '<div class="shadow-sm p-2 smooth-transition ' + (state.darkMode ? 'bg-slate-800/50' : 'bg-white') + '">';
      html += '<div class="h-3 rounded-full overflow-hidden ' + (state.darkMode ? 'bg-slate-700' : 'bg-gray-200') + '">';
      html += '<div id="progress-bar" class="h-full smooth-transition ' + (state.isPaused ? (state.darkMode ? 'bg-yellow-600' : 'bg-yellow-500') : (state.darkMode ? 'bg-indigo-500' : 'bg-indigo-600')) + '" style="width: ' + ((state.timeLeft / state.timePerQuestion) * 100) + '%"></div>';
      html += '</div></div>';

      // Game area
      html += '<div class="flex-1 overflow-y-auto p-6"><div class="max-w-4xl mx-auto">';
      
      if (state.isPaused) {
        html += '<div class="border-2 rounded-xl p-6 mb-6 text-center smooth-transition ' + (state.darkMode ? 'bg-yellow-900/20 border-yellow-500/50 backdrop-blur' : 'bg-yellow-50 border-yellow-300') + '">';
        html += '<div class="w-12 h-12 mx-auto mb-2 ' + (state.darkMode ? 'text-yellow-400' : 'text-yellow-600') + '">' + icons.pause + '</div>';
        html += '<h2 class="text-2xl font-bold mb-2 ' + (state.darkMode ? 'text-yellow-300' : 'text-yellow-800') + '">Paused</h2>';
        html += '<p class="text-base ' + (state.darkMode ? 'text-yellow-200' : 'text-yellow-700') + '">Press <kbd class="px-3 py-1 rounded font-mono text-sm ' + (state.darkMode ? 'bg-slate-700 text-yellow-300' : 'bg-white') + '">Space</kbd> or the play button to resume</p>';
        html += '</div>';
      } else if (state.currentTrial) {
        html += '<div class="rounded-2xl shadow-xl p-8 smooth-transition ' + (state.darkMode ? 'bg-slate-800/90 backdrop-blur' : 'bg-white') + '">';
        html += '<h3 class="text-sm font-semibold uppercase tracking-wide mb-4 ' + (state.darkMode ? 'text-gray-400' : 'text-gray-500') + '">Given:</h3>';
        html += '<div class="space-y-3 mb-8">';
        
        state.currentTrial.premises.forEach((premise, idx) => {
          html += '<div class="relative flex items-center justify-center text-xl p-4 rounded-lg overflow-hidden smooth-transition ' + (state.darkMode ? 'bg-slate-700/50' : 'bg-gray-50') + '" data-premise-idx="' + idx + '">';
          html += '<div class="relative z-0 flex items-center gap-2 flex-wrap justify-center">';
          html += renderStimulus(premise.stimulus1);
          html += '<span class="mx-1 text-base ' + (state.darkMode ? 'text-gray-500' : 'text-gray-400') + '">is</span>';
          html += '<span class="font-semibold px-3 py-1 rounded border text-base ' + getRelationColor(premise.relation) + '">' + premise.relation + '</span>';
          html += '<span class="mx-1 text-base ' + (state.darkMode ? 'text-gray-500' : 'text-gray-400') + '">to</span>';
          html += renderStimulus(premise.stimulus2);
          html += '</div>';
          if (state.spoilerPremises && state.hoveredPremise !== idx) {
            html += '<div class="absolute inset-0 rounded-lg z-10 ' + (state.darkMode ? 'bg-gradient-to-r from-purple-600 via-pink-600 to-indigo-600' : 'bg-gradient-to-r from-indigo-400 via-purple-400 to-pink-400') + '"></div>';
          }
          html += '</div>';
        });
        
        html += '</div>';
        
        const feedbackBorderClass = state.feedback === 'correct' ? 'border-green-500' : state.feedback === 'incorrect' ? 'border-red-500' : state.feedback === 'missed' ? 'border-orange-500' : (state.darkMode ? 'border-indigo-500' : 'border-indigo-500');
        html += '<div class="border-t-4 pt-8 ' + feedbackBorderClass + '">';
        html += '<h3 class="text-lg font-semibold mb-4 ' + (state.darkMode ? 'text-indigo-400' : 'text-indigo-600') + '">Question:</h3>';
        html += '<div class="flex items-center justify-center text-2xl p-6 rounded-xl mb-6 smooth-transition gap-2 flex-wrap ' + (state.darkMode ? 'bg-indigo-900/30' : 'bg-indigo-50') + '">';
        html += '<span class="font-bold ' + (state.darkMode ? 'text-indigo-300' : 'text-indigo-700') + '">Is</span>';
        html += renderStimulus(state.currentTrial.question.stimulus1);
        html += '<span class="mx-2 font-semibold px-4 py-2 rounded-lg border-2 text-base ' + getRelationColor(state.currentTrial.question.relation) + '">' + state.currentTrial.question.relation + '</span>';
        if (getRelationMode(state.currentTrial.question.relation) === 'equality') {
          html += '<span class="font-bold ' + (state.darkMode ? 'text-indigo-300' : 'text-indigo-700') + '">to</span>';
        }
        html += renderStimulus(state.currentTrial.question.stimulus2);
        html += '<span class="font-bold ' + (state.darkMode ? 'text-indigo-300' : 'text-indigo-700') + '">?</span>';
        html += '</div>';
        
        if (state.feedback) {
          const feedbackColor = state.feedback === 'correct' ? (state.darkMode ? 'text-green-400' : 'text-green-600') : state.feedback === 'incorrect' ? (state.darkMode ? 'text-red-400' : 'text-red-600') : (state.darkMode ? 'text-orange-400' : 'text-orange-600');
          const feedbackIcon = state.feedback === 'correct' ? icons.check : state.feedback === 'incorrect' ? icons.x : icons.clock;
          const feedbackText = state.feedback === 'correct' ? 'Correct!' : state.feedback === 'incorrect' ? 'Incorrect' : 'Time\'s Up!';
          html += '<div class="text-center text-2xl font-bold mb-6 ' + feedbackColor + '">';
          html += '<span class="inline-block w-8 h-8 mr-2 align-middle">' + feedbackIcon + '</span>' + feedbackText;
          html += '</div>';
        } else {
          html += '<div class="flex flex-col gap-4">';
          html += '<button onclick="handleAnswer(true)" class="w-full px-6 py-4 text-white text-xl font-bold rounded-xl smooth-transition transform active:scale-95 sm:hover:scale-105 ' + (state.darkMode ? 'bg-green-600 hover:bg-green-700 shadow-lg shadow-green-900/50' : 'bg-green-500 hover:bg-green-600') + '">YES <span class="text-sm">(1)</span></button>';
          html += '<button onclick="handleAnswer(false)" class="w-full px-6 py-4 text-white text-xl font-bold rounded-xl smooth-transition transform active:scale-95 sm:hover:scale-105 ' + (state.darkMode ? 'bg-red-600 hover:bg-red-700 shadow-lg shadow-red-900/50' : 'bg-red-500 hover:bg-red-600') + '">NO <span class="text-sm">(2)</span></button>';
          html += '<button onclick="handleAnswer(\'ambiguous\')" class="w-full px-6 py-4 text-white text-xl font-bold rounded-xl smooth-transition transform active:scale-95 sm:hover:scale-105 ' + (state.darkMode ? 'bg-slate-600 hover:bg-slate-700 shadow-lg shadow-slate-900/50' : 'bg-gray-500 hover:bg-gray-600') + '">CAN\'T TELL <span class="text-sm">(3)</span></button>';
          html += '</div>';
        }
        
        html += '</div></div>';
      }
      
      html += '</div></div></div>';

      // Settings Panel backdrop
      if (state.showSettings) {
        html += '<div class="sm:hidden fixed inset-0 z-40 bg-black/50 backdrop-blur-sm" onclick="closeSettings()"></div>';
      }

      // Settings Panel
      html += '<div class="smooth-transition overflow-hidden ' + (state.showSettings ? 'fixed sm:relative inset-y-0 right-0 w-[90vw] sm:w-96 z-50' : 'w-0') + ' ' + (state.darkMode ? 'bg-slate-800' : 'bg-white') + ' shadow-xl">';
      if (state.showSettings) {
        html += '<div class="h-full flex flex-col p-4">';
        html += '<div class="flex items-center justify-between mb-4">';
        html += '<div class="flex items-center"><span class="w-5 h-5 mr-2">' + icons.settings + '</span><h2 class="text-lg font-bold ' + (state.darkMode ? 'text-gray-100' : 'text-gray-800') + '">Settings</h2></div>';
        html += '<button onclick="closeSettings()" class="p-1 rounded ' + (state.darkMode ? 'hover:bg-slate-700' : 'hover:bg-gray-100') + '">' + icons.x + '</button>';
        html += '</div>';
        html += '<div class="flex-1 overflow-y-auto space-y-6">';
        
        // Dark Mode Toggle
        html += '<div><label class="block text-sm font-semibold mb-2 ' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '">Dark Mode</label>';
        html += '<button onclick="toggleDarkMode()" class="w-full flex items-center justify-between">';
        html += '<div class="relative w-14 h-7 rounded-full smooth-transition ' + (state.darkMode ? 'bg-indigo-600' : 'bg-gray-300') + '">';
        html += '<div class="absolute top-0.5 left-0.5 w-6 h-6 bg-white rounded-full smooth-transition shadow-md ' + (state.darkMode ? 'transform translate-x-7' : '') + '"></div>';
        html += '</div>';
        html += '<span class="text-sm font-medium ' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '">' + (state.darkMode ? 'Enabled' : 'Disabled') + '</span>';
        html += '</button></div>';
        
        // Difficulty
        html += '<div><label class="block text-sm font-semibold mb-2 ' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '">Premise Count</label>';
        html += '<input type="number" min="2" max="20" value="' + state.difficulty + '" onchange="updateDifficulty(this.value)" class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent smooth-transition ' + (state.darkMode ? 'bg-slate-700 border-slate-600 text-gray-100' : 'bg-white border-gray-300 text-gray-900') + '" /></div>';
        
        // Time Per Question
        html += '<div><label class="block text-sm font-semibold mb-2 ' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '">Time Per Question (seconds): ' + state.timePerQuestion.toFixed(1) + '</label>';
        html += '<input type="range" min="5" max="120" step="0.5" value="' + state.timePerQuestion + '" oninput="updateTimePerQuestion(this.value)" class="w-full" /></div>';
        
        // Spoiler Premises
        html += '<div><label class="flex items-center space-x-2 cursor-pointer">';
        html += '<input type="checkbox" ' + (state.spoilerPremises ? 'checked' : '') + ' onchange="updateSpoilerPremises(this.checked)" class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />';
        html += '<span class="text-sm font-semibold ' + (state.darkMode ? 'text-gray-300' : 'text-gray-700') + '">Spoiler Premises</span>';
        html += '</label><p class="text-xs mt-1 ml-6 ' + (state.darkMode ? 'text-gray-400' : 'text-gray-500') + '">Hover to reveal premises</p></div>';
        
        html += '</div></div>';
      }
      html += '</div>';
      
      html += '</div>';
      
      app.innerHTML = html;

      // Add hover listeners for spoiler premises
      if (state.spoilerPremises && state.currentTrial) {
        setTimeout(() => {
          document.querySelectorAll('[data-premise-idx]').forEach((el, idx) => {
            el.addEventListener('mouseenter', () => {
              state.hoveredPremise = idx;
              render();
            });
            el.addEventListener('mouseleave', () => {
              state.hoveredPremise = null;
              render();
            });
          });
        }, 0);
      }
    };

    // Global event handlers
    window.togglePause = togglePause;
    window.resetGame = resetGame;
    window.handleAnswer = handleAnswer;
    
    window.updateDifficulty = (value) => {
      state.difficulty = Math.max(2, parseInt(value) || 2);
      saveToStorage();
      render();
    };
    
    window.updateTimePerQuestion = (value) => {
      state.timePerQuestion = parseFloat(value);
      saveToStorage();
      render();
    };
    
    window.updateSpoilerPremises = (checked) => {
      state.spoilerPremises = checked;
      saveToStorage();
      render();
    };
    
    window.toggleDarkMode = () => {
      state.darkMode = !state.darkMode;
      saveToStorage();
      render();
    };
    
    window.toggleHistory = () => {
      state.showHistory = !state.showHistory;
      render();
    };
    
    window.toggleStats = () => {
      state.showStats = !state.showStats;
      render();
    };
    
    window.toggleTutorial = () => {
      state.showTutorial = !state.showTutorial;
      render();
    };
    
    window.toggleSettings = () => {
      state.showSettings = !state.showSettings;
      render();
    };
    
    window.handleBackdropClick = (event, type) => {
      if (event.target === event.currentTarget) {
        if (type === 'tutorial') state.showTutorial = false;
        render();
      }
    };
    
    window.closeTutorial = () => {
      state.showTutorial = false;
      render();
    };
    
    window.closeHistoryStats = () => {
      state.showHistory = false;
      state.showStats = false;
      render();
    };
    
    window.closeHistory = () => {
      state.showHistory = false;
      render();
    };
    
    window.closeStats = () => {
      state.showStats = false;
      render();
    };
    
    window.closeSettings = () => {
      state.showSettings = false;
      render();
    };

    // Keyboard event listener
    document.addEventListener('keydown', (e) => {
      if (e.key === ' ') {
        e.preventDefault();
        togglePause();
      } else if (!state.isPaused && !state.feedback) {
        if (e.key === '1') handleAnswer(true);
        else if (e.key === '2') handleAnswer(false);
        else if (e.key === '3') handleAnswer('ambiguous');
      }
    });

    // Initialize
    (async () => {
      await loadFromStorage();
      startNewTrial();
      startTimer();
      render();
    })();
  </script>
</body>
</html>
