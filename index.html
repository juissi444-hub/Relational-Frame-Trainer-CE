<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Relational Frame Trainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="config.js"></script>
    <style>
        * { 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body { 
            margin: 0; 
            font-family: system-ui, -apple-system, sans-serif; 
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: pan-y;
        }
        .emoji-stimulus { font-size: 2rem; line-height: 1; }
        .transition-colors { transition: background-color 0.3s, color 0.3s, border-color 0.3s; }
        input[type="range"] { 
            -webkit-appearance: none; 
            appearance: none; 
            height: 8px; 
            border-radius: 5px; 
            background: #ddd; 
            outline: none;
            touch-action: none;
        }
        input[type="range"]::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 24px; 
            height: 24px; 
            border-radius: 50%; 
            background: #6366f1; 
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb { 
            width: 24px; 
            height: 24px; 
            border-radius: 50%; 
            background: #6366f1; 
            cursor: pointer; 
            border: none;
        }
        .dark input[type="range"] { background: #475569; }
        button { 
            cursor: pointer;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        button:active { transform: scale(0.95); }
        .premise-item { transition: transform 0.2s; }
        .main-content-wrapper { 
            height: 100%; 
            overflow-y: auto; 
            overflow-x: hidden; 
            -webkit-overflow-scrolling: touch;
        }
        .sidebar-wrapper {
            position: fixed;
            inset: 0;
            z-index: 40;
            pointer-events: none;
        }
        .sidebar-content {
            pointer-events: auto;
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .modal-wrapper {
            position: fixed;
            inset: 0;
            z-index: 50;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        @media (max-width: 640px) {
            .main-content-wrapper { 
                padding-bottom: env(safe-area-inset-bottom, 20px); 
            }
            .sidebar-content {
                width: 100vw !important;
                max-width: 100vw !important;
            }
            button {
                min-height: 44px;
                min-width: 44px;
            }
        }
        input, textarea {
            font-size: 16px !important;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script>
        // Initialize Supabase client using config
        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);

        const state = {
            difficulty: 3,
            timePerQuestion: 30,
            networkComplexity: 0.5,
            spoilerPremises: false,
            darkMode: false,
            useLetters: true,
            useEmojis: false,
            useVoronoi: false,
            useMandelbrot: false,
            letterLength: 3,
            autoProgressEnabled: true,
            universalAutoProgress: true,
            targetPremiseCount: 40,
            targetAccuracy: 95,
            recentAnswers: [],
            statsHistory: [],
            showSettings: false,
            showHistory: false,
            showStats: false,
            showTutorial: false,
            showAuth: false,
            authView: 'login',
            isPaused: false,
            currentTrial: null,
            timeLeft: 30,
            score: { correct: 0, incorrect: 0, missed: 0 },
            feedback: null,
            history: [],
            hoveredPremise: null,
            enabledRelationModes: {
                equality: true,
                temporal: false,
                spatial: false,
                containment: false
            },
            premiseCounts: {
                equality: 3,
                temporal: 3,
                spatial: 3,
                containment: 3
            },
            modeProgress: {
                equality: { recentAnswers: [], timePerQuestion: 30 },
                temporal: { recentAnswers: [], timePerQuestion: 30 },
                spatial: { recentAnswers: [], timePerQuestion: 30 },
                containment: { recentAnswers: [], timePerQuestion: 30 }
            },
            user: null,
            authUsername: '',
            authPassword: '',
            authError: null,
            authLoading: false,
            saveDebounceTimer: null
        };

        const relationSets = {
            equality: ['SAME', 'OPPOSITE', 'DIFFERENT'],
            temporal: ['BEFORE', 'AFTER', 'AT'],
            spatial: ['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'],
            containment: ['CONTAINS', 'WITHIN']
        };

        const emojiList = ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ¤£', 'ðŸ˜‚', 'ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜š', 'ðŸ˜™', 'ðŸ¥²', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜', 'ðŸ¤‘', 'ðŸ¤—', 'ðŸ¤­', 'ðŸ¤«', 'ðŸ¤”', 'ðŸ¤', 'ðŸ¤¨', 'ðŸ˜', 'ðŸ˜‘', 'ðŸ˜¶', 'ðŸ˜', 'ðŸ˜’', 'ðŸ™„', 'ðŸ˜¬', 'ðŸ¤¥', 'ðŸ˜Œ', 'ðŸ˜”', 'ðŸ˜ª', 'ðŸ¤¤', 'ðŸ˜´'];

        let timerId = null;

        const authBackend = {
            async register(username, password) {
                try {
                    const fakeEmail = `${username.toLowerCase().replace(/[^a-z0-9]/g, '')}@rftapp.example.com`;
                    
                    const { data: authData, error: authError } = await supabaseClient.auth.signUp({
                        email: fakeEmail,
                        password: password,
                        options: {
                            data: { username: username },
                            emailRedirectTo: undefined,
                            email_confirm: false
                        }
                    });
                    
                    if (authError) throw authError;
                    
                    if (authData.user) {
                        const { error: progressError } = await supabaseClient
                            .from('user_progress')
                            .insert({
                                user_id: authData.user.id,
                                username: username,
                                score: { correct: 0, incorrect: 0, missed: 0 },
                                history: [],
                                stats_history: [],
                                settings: {},
                                recent_answers: []
                            });
                        
                        if (progressError) console.error('Progress init error:', progressError);
                    }
                    
                    return { 
                        success: true, 
                        user: authData.user ? {
                            id: authData.user.id,
                            username: username
                        } : null
                    };
                } catch (error) {
                    console.error('Register error:', error);
                    return { success: false, error: error.message };
                }
            },
            
            async login(username, password) {
                try {
                    const fakeEmail = `${username.toLowerCase().replace(/[^a-z0-9]/g, '')}@rftapp.com`;
                    const { data, error } = await supabaseClient.auth.signInWithPassword({
                        email: fakeEmail,
                        password: password
                    });
                    
                    if (error) throw error;
                    
                    return { 
                        success: true, 
                        user: { 
                            id: data.user.id,
                            username: data.user.user_metadata?.username || username
                        } 
                    };
                } catch (error) {
                    console.error('Login error:', error);
                    return { success: false, error: 'Invalid credentials' };
                }
            },
            
            async logout() {
                try {
                    const { error } = await supabaseClient.auth.signOut();
                    if (error) throw error;
                    return { success: true };
                } catch (error) {
                    console.error('Logout error:', error);
                    return { success: false, error: error.message };
                }
            },
            
            async getSession() {
                try {
                    const { data: { session }, error } = await supabaseClient.auth.getSession();
                    if (error) throw error;
                    
                    if (session) {
                        return {
                            success: true,
                            user: {
                                id: session.user.id,
                                username: session.user.user_metadata?.username || 'User'
                            }
                        };
                    }
                    return { success: false };
                } catch (error) {
                    console.error('Session error:', error);
                    return { success: false, error: error.message };
                }
            },
            
            async saveProgress(userId, progressData) {
                try {
                    const { error } = await supabaseClient
                        .from('user_progress')
                        .upsert({
                            user_id: userId,
                            score: progressData.score,
                            history: progressData.history.slice(-100),
                            stats_history: progressData.statsHistory.slice(-100),
                            settings: progressData.settings,
                            recent_answers: progressData.recentAnswers.slice(-100),
                            last_sync: new Date().toISOString()
                        }, {
                            onConflict: 'user_id'
                        });
                    
                    if (error) throw error;
                    return { success: true };
                } catch (error) {
                    console.error('Save progress error:', error);
                    return { success: false, error: error.message };
                }
            },
            
            async loadProgress(userId) {
                try {
                    const { data, error } = await supabaseClient
                        .from('user_progress')
                        .select('*')
                        .eq('user_id', userId)
                        .single();
                    
                    if (error) {
                        if (error.code === 'PGRST116') {
                            return {
                                success: true,
                                data: {
                                    score: { correct: 0, incorrect: 0, missed: 0 },
                                    history: [],
                                    statsHistory: [],
                                    settings: {},
                                    recentAnswers: []
                                }
                            };
                        }
                        throw error;
                    }
                    
                    return { 
                        success: true, 
                        data: {
                            score: data.score || { correct: 0, incorrect: 0, missed: 0 },
                            history: data.history || [],
                            statsHistory: data.stats_history || [],
                            settings: data.settings || {},
                            recentAnswers: data.recent_answers || []
                        }
                    };
                } catch (error) {
                    console.error('Load progress error:', error);
                    return { success: false, error: error.message };
                }
            }
        };

        function saveToStorage() {
            if (state.saveDebounceTimer) {
                clearTimeout(state.saveDebounceTimer);
            }
            
            state.saveDebounceTimer = setTimeout(() => {
                const progressData = {
                    score: state.score,
                    history: state.history,
                    statsHistory: state.statsHistory,
                    settings: {
                        difficulty: state.difficulty,
                        timePerQuestion: state.timePerQuestion,
                        networkComplexity: state.networkComplexity,
                        spoilerPremises: state.spoilerPremises,
                        darkMode: state.darkMode,
                        useLetters: state.useLetters,
                        useEmojis: state.useEmojis,
                        useVoronoi: state.useVoronoi,
                        useMandelbrot: state.useMandelbrot,
                        letterLength: state.letterLength,
                        autoProgressEnabled: state.autoProgressEnabled,
                        universalAutoProgress: state.universalAutoProgress,
                        targetPremiseCount: state.targetPremiseCount,
                        targetAccuracy: state.targetAccuracy,
                        enabledRelationModes: state.enabledRelationModes,
                        premiseCounts: state.premiseCounts,
                        modeProgress: state.modeProgress
                    },
                    recentAnswers: state.recentAnswers
                };
                
                try {
                    localStorage.setItem('rft-data', JSON.stringify(progressData));
                    
                    if (state.user?.id) {
                        authBackend.saveProgress(state.user.id, progressData);
                    }
                } catch (error) {
                    console.error('Save failed:', error);
                }
            }, 1000);
        }

        function loadFromStorage() {
            try {
                const data = localStorage.getItem('rft-data');
                if (data) {
                    const parsed = JSON.parse(data);
                    if (parsed.score) state.score = parsed.score;
                    if (parsed.history) state.history = parsed.history;
                    if (parsed.statsHistory) state.statsHistory = parsed.statsHistory;
                    if (parsed.recentAnswers) state.recentAnswers = parsed.recentAnswers;
                    if (parsed.settings) {
                        Object.keys(parsed.settings).forEach(key => {
                            if (parsed.settings[key] !== undefined) {
                                state[key] = parsed.settings[key];
                            }
                        });
                    }
                }
            } catch (error) {
                console.log('No saved data found');
            }
        }

        async function loadUserProgress(userId) {
            try {
                const result = await authBackend.loadProgress(userId);
                if (result.success && result.data) {
                    const data = result.data;
                    
                    if (data.score) state.score = data.score;
                    if (data.history) state.history = data.history;
                    if (data.statsHistory) state.statsHistory = data.statsHistory;
                    if (data.recentAnswers) state.recentAnswers = data.recentAnswers;
                    
                    if (data.settings) {
                        Object.keys(data.settings).forEach(key => {
                            if (data.settings[key] !== undefined) {
                                state[key] = data.settings[key];
                            }
                        });
                    }
                    
                    localStorage.setItem('rft-data', JSON.stringify(data));
                }
            } catch (error) {
                console.error('Failed to load user progress:', error);
            }
        }

        function getRelationMode(relation) {
            if (['SAME', 'OPPOSITE', 'DIFFERENT'].includes(relation)) return 'equality';
            if (['BEFORE', 'AFTER', 'AT'].includes(relation)) return 'temporal';
            if (['CONTAINS', 'WITHIN'].includes(relation)) return 'containment';
            return 'spatial';
        }

        function deriveRelation(rel1, rel2) {
            const mode1 = getRelationMode(rel1);
            const mode2 = getRelationMode(rel2);
            
            if (mode1 !== mode2) return 'AMBIGUOUS';
            
            if (mode1 === 'equality') {
                if (rel1 === 'SAME') return rel2;
                if (rel2 === 'SAME') return rel1;
                if (rel1 === 'OPPOSITE' && rel2 === 'OPPOSITE') return 'SAME';
                if (rel1 === 'DIFFERENT' || rel2 === 'DIFFERENT') return 'AMBIGUOUS';
                return 'AMBIGUOUS';
            } else if (mode1 === 'temporal') {
                if (rel1 === 'AT') return rel2;
                if (rel2 === 'AT') return rel1;
                if (rel1 === 'BEFORE' && rel2 === 'BEFORE') return 'BEFORE';
                if (rel1 === 'AFTER' && rel2 === 'AFTER') return 'AFTER';
                return 'AMBIGUOUS';
            } else if (mode1 === 'containment') {
                if (rel1 === 'CONTAINS' && rel2 === 'CONTAINS') return 'CONTAINS';
                if (rel1 === 'WITHIN' && rel2 === 'WITHIN') return 'WITHIN';
                return 'AMBIGUOUS';
            } else {
                if (rel1 === rel2) return rel1;
                return 'AMBIGUOUS';
            }
        }

        function findAllPaths(graph, start, end, currentPath = [], visited = new Set(), allPaths = []) {
            if (start === end && currentPath.length > 0) {
                allPaths.push([...currentPath]);
                return allPaths;
            }
            visited.add(start);
            for (const edge of graph) {
                let nextNode = null, edgeToAdd = null;
                if (edge.stimulus1 === start && !visited.has(edge.stimulus2)) {
                    nextNode = edge.stimulus2;
                    edgeToAdd = { ...edge, reversed: false };
                } else if (edge.stimulus2 === start && !visited.has(edge.stimulus1)) {
                    nextNode = edge.stimulus1;
                    const reversedRelation = (edge.relation === 'CONTAINS') ? 'WITHIN' : 
                                            (edge.relation === 'WITHIN') ? 'CONTAINS' : edge.relation;
                    edgeToAdd = { ...edge, relation: reversedRelation, reversed: true };
                }
                if (nextNode) {
                    currentPath.push(edgeToAdd);
                    findAllPaths(graph, nextNode, end, currentPath, new Set(visited), allPaths);
                    currentPath.pop();
                }
            }
            return allPaths;
        }

        function deriveFromPath(path) {
            if (!path || path.length === 0) return null;
            let result = path[0].relation;
            for (let i = 1; i < path.length; i++) {
                result = deriveRelation(result, path[i].relation);
                if (result === 'AMBIGUOUS') return 'AMBIGUOUS';
            }
            return result;
        }

        function deriveRelationFromGraph(graph, start, end) {
            if (start === end) {
                if (state.enabledRelationModes.equality) return 'SAME';
                if (state.enabledRelationModes.temporal) return 'AT';
                return null;
            }
            const allPaths = findAllPaths(graph, start, end);
            if (allPaths.length === 0) return null;
            
            const derivedRelations = allPaths.map(path => deriveFromPath(path)).filter(r => r !== null);
            if (derivedRelations.length === 0) return null;
            
            const nonAmbiguous = derivedRelations.filter(r => r !== 'AMBIGUOUS');
            if (nonAmbiguous.length === 0) return 'AMBIGUOUS';
            
            const firstRel = nonAmbiguous[0];
            const allAgree = nonAmbiguous.every(rel => rel === firstRel);
            
            return allAgree ? firstRel : 'AMBIGUOUS';
        }

        function generateStimulus() {
            const availableTypes = [];
            if (state.useLetters) availableTypes.push('letters');
            if (state.useEmojis) availableTypes.push('emojis');
            if (state.useVoronoi) availableTypes.push('voronoi');
            if (state.useMandelbrot) availableTypes.push('mandelbrot');
            
            if (availableTypes.length === 0) availableTypes.push('letters');
            
            const selectedType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            if (selectedType === 'emojis') {
                return emojiList[Math.floor(Math.random() * emojiList.length)];
            } else if (selectedType === 'voronoi') {
                return `voronoi_${Math.floor(Math.random() * 1000000)}`;
            } else if (selectedType === 'mandelbrot') {
                return `mandelbrot_${Math.floor(Math.random() * 1000000)}`;
            } else {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < state.letterLength; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }
        }

        function generateVoronoiSVG(seed) {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
            const random = (s) => { const x = Math.sin(s++) * 10000; return x - Math.floor(x); };
            
            let svgContent = '<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="border-radius: 0.375rem;">';
            const gridSize = 4;
            const tileSize = 64 / gridSize;
            
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const colorIndex = Math.floor(random(seed + row * gridSize + col) * colors.length);
                    const color = colors[colorIndex];
                    const x = col * tileSize;
                    const y = row * tileSize;
                    svgContent += `<rect x="${x}" y="${y}" width="${tileSize}" height="${tileSize}" fill="${color}" opacity="0.9"/>`;
                }
            }
            svgContent += '</svg>';
            return svgContent;
        }

        function generateMandelbrotSVG(seed) {
            const random = (s) => { const x = Math.sin(s++) * 10000; return x - Math.floor(x); };
            const centerX = -0.7 + (random(seed) - 0.5) * 0.5;
            const centerY = 0 + (random(seed + 100) - 0.5) * 0.5;
            const zoom = 0.3 + random(seed + 200) * 0.7;
            
            const width = 64, height = 64, maxIterations = 50;
            let svgContent = '<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="border-radius: 0.375rem;">';
            const colors = ['#000033', '#000055', '#0000AA', '#0000FF', '#0055FF', '#00AAFF', '#00FFFF', '#55FFAA'];
            
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x0 = centerX + (px / width - 0.5) * zoom;
                    const y0 = centerY + (py / height - 0.5) * zoom;
                    let x = 0, y = 0, iteration = 0;
                    
                    while (x * x + y * y <= 4 && iteration < maxIterations) {
                        const xtemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xtemp;
                        iteration++;
                    }
                    
                    const color = iteration === maxIterations ? '#000000' : colors[Math.floor((iteration / maxIterations) * (colors.length - 1))];
                    svgContent += `<rect x="${px}" y="${py}" width="1" height="1" fill="${color}"/>`;
                }
            }
            svgContent += '</svg>';
            return svgContent;
        }

        function generateTrial() {
            const enabledModes = Object.keys(state.enabledRelationModes).filter(mode => state.enabledRelationModes[mode]);
            const chosenMode = enabledModes.length > 0 ? enabledModes[Math.floor(Math.random() * enabledModes.length)] : 'equality';
            const activeRelations = relationSets[chosenMode];
            
            const premiseCount = state.premiseCounts[chosenMode];
            const numStimuli = Math.max(3, premiseCount + 1);
            const stimuli = [generateStimulus()];
            const premises = [];
            
            for (let p = 0; p < premiseCount; p++) {
                let chosenPair = null;
                const ambiguousPairs = [];
                
                for (let i = 0; i < stimuli.length; i++) {
                    for (let j = i + 1; j < stimuli.length; j++) {
                        const s1 = stimuli[i], s2 = stimuli[j];
                        const alreadyConnected = premises.some(pr => (pr.stimulus1 === s1 && pr.stimulus2 === s2) || (pr.stimulus1 === s2 && pr.stimulus2 === s1));
                        if (!alreadyConnected) {
                            const derived = deriveRelationFromGraph(premises, s1, s2);
                            if (derived === 'AMBIGUOUS') ambiguousPairs.push({ s1, s2 });
                        }
                    }
                }
                
                if (ambiguousPairs.length > 0 && Math.random() < state.networkComplexity) {
                    chosenPair = ambiguousPairs[Math.floor(Math.random() * ambiguousPairs.length)];
                } else if (stimuli.length < numStimuli) {
                    const newStimulus = generateStimulus();
                    stimuli.push(newStimulus);
                    chosenPair = { s1: stimuli[Math.floor(Math.random() * (stimuli.length - 1))], s2: newStimulus };
                } else {
                    const availablePairs = [];
                    for (let i = 0; i < stimuli.length; i++) {
                        for (let j = i + 1; j < stimuli.length; j++) {
                            const s1 = stimuli[i], s2 = stimuli[j];
                            if (!premises.some(pr => (pr.stimulus1 === s1 && pr.stimulus2 === s2) || (pr.stimulus1 === s2 && pr.stimulus2 === s1))) {
                                availablePairs.push({ s1, s2 });
                            }
                        }
                    }
                    chosenPair = availablePairs.length > 0 ? availablePairs[Math.floor(Math.random() * availablePairs.length)] : { s1: stimuli[0], s2: stimuli[1] };
                }
                
                if (chosenPair) {
                    premises.push({
                        stimulus1: chosenPair.s1,
                        relation: activeRelations[Math.floor(Math.random() * activeRelations.length)],
                        stimulus2: chosenPair.s2
                    });
                }
            }
            
            const startIdx = Math.floor(Math.random() * stimuli.length);
            let endIdx = Math.floor(Math.random() * stimuli.length);
            if (startIdx === endIdx) endIdx = (endIdx + 1) % stimuli.length;
            
            const derivedRelation = deriveRelationFromGraph(premises, stimuli[startIdx], stimuli[endIdx]);
            let questionRelation, correctAnswer;
            
            if (derivedRelation === 'AMBIGUOUS' || derivedRelation === null) {
                questionRelation = activeRelations[Math.floor(Math.random() * activeRelations.length)];
                correctAnswer = 'ambiguous';
            } else {
                const askCompatible = Math.random() < 0.5;
                if (askCompatible) {
                    questionRelation = derivedRelation;
                    correctAnswer = true;
                } else {
                    const incompatible = activeRelations.filter(r => r !== derivedRelation);
                    if (incompatible.length > 0) {
                        questionRelation = incompatible[Math.floor(Math.random() * incompatible.length)];
                        correctAnswer = false;
                    } else {
                        questionRelation = derivedRelation;
                        correctAnswer = true;
                    }
                }
            }

            return {
                premises,
                question: { stimulus1: stimuli[startIdx], relation: questionRelation, stimulus2: stimuli[endIdx] },
                correctAnswer,
                derivedRelation: derivedRelation || 'AMBIGUOUS',
                allStimuli: stimuli,
                mode: chosenMode
            };
        }

        function startNewTrial() {
            state.currentTrial = generateTrial();
            const mode = state.currentTrial.mode;
            state.timeLeft = state.modeProgress[mode].timePerQuestion;
            state.feedback = null;
            render();
            startTimer();
        }

        function startTimer() {
            if (timerId) clearInterval(timerId);
            timerId = setInterval(() => {
                if (!state.isPaused && !state.feedback && state.timeLeft > 0) {
                    const hasMandelbrot = state.currentTrial?.premises.some(p => 
                        p.stimulus1.startsWith('mandelbrot_') || p.stimulus2.startsWith('mandelbrot_')
                    ) || false;
                    const speedMultiplier = (state.useMandelbrot && hasMandelbrot) ? 5 : 1;
                    state.timeLeft = Math.max(0, state.timeLeft - (0.1 * speedMultiplier));
                    render();
                    
                    if (state.timeLeft <= 0) {
                        handleTimeout();
                    }
                }
            }, 100);
        }

        function handleTimeout() {
            state.score.missed++;
            state.feedback = 'missed';
            const mode = state.currentTrial.mode;
            const modeTime = state.modeProgress[mode].timePerQuestion;
            const entry = {
                trial: state.currentTrial,
                userAnswer: null,
                isCorrect: false,
                timestamp: Date.now(),
                timeUsed: modeTime,
                premiseCount: state.currentTrial.premises.length
            };
            state.history.push(entry);
            state.statsHistory.push({
                timestamp: Date.now(),
                timeUsed: modeTime,
                premiseCount: state.currentTrial.premises.length,
                isCorrect: false,
                mode: mode
            });
            
            state.recentAnswers.push(false);
            state.modeProgress[mode].recentAnswers.push(false);
            checkAutoProgress(mode);
            
            render();
            saveToStorage();
            setTimeout(() => startNewTrial(), 1500);
        }

        function handleAnswer(userAnswer) {
            if (state.isPaused || state.feedback) return;
            
            const isCorrect = userAnswer === state.currentTrial.correctAnswer;
            const mode = state.currentTrial.mode;
            const modeTime = state.modeProgress[mode].timePerQuestion;
            const timeUsed = modeTime - state.timeLeft;
            
            if (isCorrect) {
                state.score.correct++;
            } else {
                state.score.incorrect++;
            }
            
            state.feedback = isCorrect ? 'correct' : 'incorrect';
            
            const entry = {
                trial: state.currentTrial,
                userAnswer,
                isCorrect,
                timestamp: Date.now(),
                timeUsed,
                premiseCount: state.currentTrial.premises.length
            };
            
            state.history.push(entry);
            state.statsHistory.push({
                timestamp: Date.now(),
                timeUsed,
                premiseCount: state.currentTrial.premises.length,
                isCorrect,
                mode: mode
            });
            
            state.recentAnswers.push(isCorrect);
            state.modeProgress[mode].recentAnswers.push(isCorrect);
            checkAutoProgress(mode);
            
            render();
            saveToStorage();
            setTimeout(() => startNewTrial(), 1500);
        }

        function checkAutoProgress(mode) {
            if (!state.autoProgressEnabled) return;
            
            if (state.universalAutoProgress) {
                if (state.recentAnswers.length < state.targetPremiseCount) return;
                
                const recentWindow = state.recentAnswers.slice(-state.targetPremiseCount);
                const accuracy = (recentWindow.filter(a => a).length / state.targetPremiseCount) * 100;
                
                if (accuracy >= state.targetAccuracy) {
                    if (state.timePerQuestion > 10) {
                        state.timePerQuestion = Math.max(10, state.timePerQuestion - 5);
                        Object.keys(state.modeProgress).forEach(m => {
                            state.modeProgress[m].timePerQuestion = state.timePerQuestion;
                        });
                        state.recentAnswers = [];
                    } else {
                        Object.keys(state.premiseCounts).forEach(m => {
                            state.premiseCounts[m] = Math.min(100, state.premiseCounts[m] + 1);
                        });
                        state.timePerQuestion = 30;
                        Object.keys(state.modeProgress).forEach(m => {
                            state.modeProgress[m].timePerQuestion = 30;
                        });
                        state.recentAnswers = [];
                    }
                }
            } else {
                const modeData = state.modeProgress[mode];
                if (modeData.recentAnswers.length < state.targetPremiseCount) return;
                
                const recentWindow = modeData.recentAnswers.slice(-state.targetPremiseCount);
                const accuracy = (recentWindow.filter(a => a).length / state.targetPremiseCount) * 100;
                
                if (accuracy >= state.targetAccuracy) {
                    if (modeData.timePerQuestion > 10) {
                        modeData.timePerQuestion = Math.max(10, modeData.timePerQuestion - 5);
                        modeData.recentAnswers = [];
                    } else {
                        state.premiseCounts[mode] = Math.min(100, state.premiseCounts[mode] + 1);
                        modeData.timePerQuestion = 30;
                        modeData.recentAnswers = [];
                    }
                }
            }
        }

        function togglePause() {
            state.isPaused = !state.isPaused;
            if (!state.isPaused) {
                state.currentTrial = generateTrial();
                const mode = state.currentTrial.mode;
                state.timeLeft = state.modeProgress[mode].timePerQuestion;
                state.feedback = null;
                startTimer();
            } else {
                if (state.currentTrial) {
                    const mode = state.currentTrial.mode;
                    state.timeLeft = state.modeProgress[mode].timePerQuestion;
                }
            }
            render();
        }

        function resetGame() {
            state.score = { correct: 0, incorrect: 0, missed: 0 };
            state.history = [];
            state.recentAnswers = [];
            state.statsHistory = [];
            state.modeProgress = {
                equality: { recentAnswers: [], timePerQuestion: 30 },
                temporal: { recentAnswers: [], timePerQuestion: 30 },
                spatial: { recentAnswers: [], timePerQuestion: 30 },
                containment: { recentAnswers: [], timePerQuestion: 30 }
            };
            startNewTrial();
            saveToStorage();
        }

        function getAnswerLabel(answer) {
            if (answer === true) return 'YES';
            if (answer === false) return 'NO';
            if (answer === 'ambiguous') return "CAN'T TELL";
            return 'NO ANSWER';
        }

        function getRelationColor(relation) {
            const colors = {
                dark: {
                    'SAME': 'bg-green-900/40 text-green-300 border-green-500',
                    'OPPOSITE': 'bg-red-900/40 text-red-300 border-red-500',
                    'DIFFERENT': 'bg-blue-900/40 text-blue-300 border-blue-500',
                    'BEFORE': 'bg-purple-900/40 text-purple-300 border-purple-500',
                    'AFTER': 'bg-orange-900/40 text-orange-300 border-orange-500',
                    'AT': 'bg-cyan-900/40 text-cyan-300 border-cyan-500',
                    'CONTAINS': 'bg-blue-900/40 text-blue-300 border-blue-500',
                    'WITHIN': 'bg-green-900/40 text-green-300 border-green-500',
                    'spatial': 'bg-teal-900/40 text-teal-300 border-teal-500'
                },
                light: {
                    'SAME': 'bg-green-100 text-green-700 border-green-300',
                    'OPPOSITE': 'bg-red-100 text-red-700 border-red-300',
                    'DIFFERENT': 'bg-blue-100 text-blue-700 border-blue-300',
                    'BEFORE': 'bg-purple-100 text-purple-700 border-purple-300',
                    'AFTER': 'bg-orange-100 text-orange-700 border-orange-300',
                    'AT': 'bg-cyan-100 text-cyan-700 border-cyan-300',
                    'CONTAINS': 'bg-blue-100 text-blue-700 border-blue-300',
                    'WITHIN': 'bg-green-100 text-green-700 border-green-300',
                    'spatial': 'bg-teal-100 text-teal-700 border-teal-300'
                }
            };
            
            const mode = state.darkMode ? 'dark' : 'light';
            if (['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'].includes(relation)) {
                return colors[mode]['spatial'];
            }
            return colors[mode][relation] || colors[mode]['DIFFERENT'];
        }

        function renderStimulus(stimulus) {
            if (stimulus.startsWith('voronoi_')) {
                const svg = generateVoronoiSVG(parseInt(stimulus.split('_')[1]));
                return `<div class="inline-block w-16 h-16 align-middle border-2 border-gray-300 rounded-md overflow-hidden">${svg}</div>`;
            }
            if (stimulus.startsWith('mandelbrot_')) {
                const svg = generateMandelbrotSVG(parseInt(stimulus.split('_')[1]));
                return `<div class="inline-block w-16 h-16 align-middle border-2 border-gray-300 rounded-md overflow-hidden">${svg}</div>`;
            }
            const isEmoji = emojiList.includes(stimulus);
            const colorClass = state.darkMode ? 'text-indigo-400' : 'text-indigo-600';
            return `<span class="font-bold ${isEmoji ? 'emoji-stimulus' : ''} ${colorClass}">${stimulus}</span>`;
        }

        // Due to length, render functions and event handlers will be in a separate continuation
        // Include render(), attachEventListeners(), and all window functions
