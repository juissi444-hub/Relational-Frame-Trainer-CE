<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Relational Frame Trainer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .smooth-transition { transition: all 0.3s ease; }
    input[type="range"] { accent-color: rgb(79, 70, 229); }
  </style>
</head>
<body class="m-0 p-0 overflow-hidden">
  <div id="app"></div>

  <script>
    // State management
    const state = {
      difficulty: 3,
      timePerQuestion: 30,
      networkComplexity: 0.5,
      spoilerPremises: false,
      darkMode: false,
      useLetters: true,
      useEmojis: false,
      useVoronoi: false,
      letterLength: 3,
      autoProgressEnabled: true,
      targetPremiseCount: 40,
      targetAccuracy: 95,
      recentAnswers: [],
      statsHistory: [],
      showSettings: false,
      showHistory: false,
      showStats: false,
      showTutorial: false,
      isPaused: false,
      currentTrial: null,
      timeLeft: 30,
      score: { correct: 0, incorrect: 0, missed: 0 },
      feedback: null,
      history: [],
      hoveredPremise: null,
      enabledRelationModes: {
        equality: true,
        temporal: false,
        spatial: false,
        containment: false
      }
    };

    const relationSets = {
      equality: ['SAME', 'OPPOSITE', 'DIFFERENT'],
      temporal: ['BEFORE', 'AFTER', 'AT'],
      spatial: ['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'],
      containment: ['CONTAINS', 'WITHIN']
    };

    const emojiList = ['ðŸŒŸ', 'ðŸŽ¨', 'ðŸŽ­', 'ðŸŽª', 'ðŸŽ¯', 'ðŸŽ²', 'ðŸŽ¸', 'ðŸŽ¹', 'ðŸŽº', 'ðŸŽ»', 'ðŸŒˆ', 'ðŸŒŠ', 'ðŸŒ™', 'â­', 'ðŸ”¥', 'ðŸ’Ž', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ¼', 'ðŸ€', 'ðŸ', 'ðŸ‚', 'ðŸƒ', 'ðŸŽˆ', 'ðŸŽ‰', 'ðŸŽŠ', 'ðŸŽ', 'ðŸ†', 'âš¡', 'ðŸ’«', 'âœ¨', 'ðŸŒ ', 'ðŸ”®', 'ðŸ’', 'ðŸŽ€', 'ðŸŒ¹', 'ðŸ¦‹', 'ðŸ', 'ðŸž', 'ðŸ¦„', 'ðŸ‰', 'ðŸ¦Š', 'ðŸº', 'ðŸ¦', 'ðŸ¯', 'ðŸ»', 'ðŸ¼', 'ðŸ¨', 'ðŸ¸', 'ðŸ¦‰', 'ðŸ¦…', 'ðŸ¦†', 'ðŸ¦¢', 'ðŸ§', 'ðŸ™', 'ðŸ¦‘', 'ðŸ¦€', 'ðŸ ', 'ðŸ¡', 'ðŸ¬', 'ðŸ³', 'ðŸ¦ˆ', 'ðŸŽ', 'ðŸŠ', 'ðŸ‹', 'ðŸŒ', 'ðŸ‰', 'ðŸ‡', 'ðŸ“', 'ðŸ«', 'ðŸ’', 'ðŸ‘', 'ðŸ¥­', 'ðŸ', 'ðŸ¥¥', 'ðŸ¥'];

    let timerInterval = null;

    // Helper functions
    const generateVoronoiSVG = (seed) => {
      const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
      const random = (s) => { const x = Math.sin(s++) * 10000; return x - Math.floor(x); };
      const points = [];
      for (let i = 0; i < 8; i++) {
        points.push({ x: random(seed + i) * 100, y: random(seed + i + 100) * 100, color: colors[i % colors.length] });
      }
      return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">${points.map((p, i) => `<circle cx="${p.x}" cy="${p.y}" r="${15 + random(seed + i + 200) * 10}" fill="${p.color}" opacity="0.7" />`).join('')}</svg>`;
    };

    const generateStimulus = () => {
      const availableTypes = [];
      if (state.useLetters) availableTypes.push('letters');
      if (state.useEmojis) availableTypes.push('emojis');
      if (state.useVoronoi) availableTypes.push('voronoi');
      
      if (availableTypes.length === 0) availableTypes.push('letters');
      
      const selectedType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      
      if (selectedType === 'emojis') {
        return emojiList[Math.floor(Math.random() * emojiList.length)];
      } else if (selectedType === 'voronoi') {
        return `voronoi_${Math.floor(Math.random() * 1000000)}`;
      } else {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let result = '';
        for (let i = 0; i < state.letterLength; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
        return result;
      }
    };

    const getRelationMode = (relation) => {
      if (['SAME', 'OPPOSITE', 'DIFFERENT'].includes(relation)) return 'equality';
      if (['BEFORE', 'AFTER', 'AT'].includes(relation)) return 'temporal';
      if (['CONTAINS', 'WITHIN'].includes(relation)) return 'containment';
      return 'spatial';
    };

    const deriveRelation = (rel1, rel2) => {
      const mode1 = getRelationMode(rel1);
      const mode2 = getRelationMode(rel2);
      
      if (mode1 !== mode2) return 'AMBIGUOUS';
      
      if (mode1 === 'equality') {
        if (rel1 === 'SAME') return rel2;
        if (rel2 === 'SAME') return rel1;
        if (rel1 === 'OPPOSITE' && rel2 === 'OPPOSITE') return 'SAME';
        if (rel1 === 'OPPOSITE' && rel2 === 'DIFFERENT') return 'DIFFERENT';
        if (rel1 === 'DIFFERENT' && rel2 === 'OPPOSITE') return 'DIFFERENT';
        if (rel1 === 'DIFFERENT' && rel2 === 'DIFFERENT') return 'AMBIGUOUS';
        return 'AMBIGUOUS';
      } else if (mode1 === 'temporal') {
        if (rel1 === 'AT') return rel2;
        if (rel2 === 'AT') return rel1;
        if (rel1 === 'BEFORE' && rel2 === 'BEFORE') return 'BEFORE';
        if (rel1 === 'AFTER' && rel2 === 'AFTER') return 'AFTER';
        if (rel1 === 'BEFORE' && rel2 === 'AFTER') return 'AMBIGUOUS';
        if (rel1 === 'AFTER' && rel2 === 'BEFORE') return 'AMBIGUOUS';
        return 'AMBIGUOUS';
      } else if (mode1 === 'containment') {
        if (rel1 === 'CONTAINS' && rel2 === 'CONTAINS') return 'CONTAINS';
        if (rel1 === 'WITHIN' && rel2 === 'WITHIN') return 'WITHIN';
        if (rel1 === 'CONTAINS' && rel2 === 'WITHIN') return 'AMBIGUOUS';
        if (rel1 === 'WITHIN' && rel2 === 'CONTAINS') return 'AMBIGUOUS';
        return 'AMBIGUOUS';
      } else {
        const opposites = {
          'NORTH': 'SOUTH', 'SOUTH': 'NORTH',
          'EAST': 'WEST', 'WEST': 'EAST',
          'NORTHEAST': 'SOUTHWEST', 'SOUTHWEST': 'NORTHEAST',
          'NORTHWEST': 'SOUTHEAST', 'SOUTHEAST': 'NORTHWEST'
        };
        
        if (rel1 === rel2) return rel1;
        if (opposites[rel1] === rel2) return 'AMBIGUOUS';
        
        return 'AMBIGUOUS';
      }
    };

    const findAllPaths = (graph, start, end, currentPath = [], visited = new Set(), allPaths = []) => {
      if (start === end && currentPath.length > 0) {
        allPaths.push([...currentPath]);
        return allPaths;
      }
      visited.add(start);
      for (const edge of graph) {
        let nextNode = null, edgeToAdd = null;
        if (edge.stimulus1 === start && !visited.has(edge.stimulus2)) {
          nextNode = edge.stimulus2;
          edgeToAdd = { ...edge, reversed: false };
        } else if (edge.stimulus2 === start && !visited.has(edge.stimulus1)) {
          nextNode = edge.stimulus1;
          edgeToAdd = { ...edge, reversed: true };
        }
        if (nextNode) {
          currentPath.push(edgeToAdd);
          findAllPaths(graph, nextNode, end, currentPath, new Set(visited), allPaths);
          currentPath.pop();
        }
      }
      return allPaths;
    };

    const deriveFromPath = (path) => {
      if (!path || path.length === 0) return null;
      let result = path[0].relation;
      for (let i = 1; i < path.length; i++) {
        result = deriveRelation(result, path[i].relation);
        if (result === 'AMBIGUOUS') return 'AMBIGUOUS';
      }
      return result;
    };

    const deriveRelationFromGraph = (graph, start, end) => {
      if (start === end) {
        if (state.enabledRelationModes.equality) return 'SAME';
        if (state.enabledRelationModes.temporal) return 'AT';
        return null;
      }
      const allPaths = findAllPaths(graph, start, end);
      if (allPaths.length === 0) return null;
      
      const derivedRelations = allPaths.map(path => deriveFromPath(path)).filter(r => r !== null);
      if (derivedRelations.length === 0) return null;
      
      const nonAmbiguous = derivedRelations.filter(r => r !== 'AMBIGUOUS');
      if (nonAmbiguous.length === 0) return 'AMBIGUOUS';
      
      const firstRel = nonAmbiguous[0];
      const allAgree = nonAmbiguous.every(rel => rel === firstRel);
      
      return allAgree ? firstRel : 'AMBIGUOUS';
    };

    const generateTrial = () => {
      const enabledModes = Object.keys(state.enabledRelationModes).filter(mode => state.enabledRelationModes[mode]);
      const chosenMode = enabledModes.length > 0 
        ? enabledModes[Math.floor(Math.random() * enabledModes.length)]
        : 'equality';
      const activeRelations = relationSets[chosenMode];
      
      const numStimuli = Math.max(3, state.difficulty + 1);
      const stimuli = [generateStimulus()];
      const premises = [];
      
      for (let p = 0; p < state.difficulty; p++) {
        let chosenPair = null;
        const ambiguousPairs = [];
        for (let i = 0; i < stimuli.length; i++) {
          for (let j = i + 1; j < stimuli.length; j++) {
            const s1 = stimuli[i], s2 = stimuli[j];
            const alreadyConnected = premises.some(pr => (pr.stimulus1 === s1 && pr.stimulus2 === s2) || (pr.stimulus1 === s2 && pr.stimulus2 === s1));
            if (!alreadyConnected) {
              const derived = deriveRelationFromGraph(premises, s1, s2);
              if (derived === 'AMBIGUOUS') ambiguousPairs.push({ s1, s2 });
            }
          }
        }
        if (ambiguousPairs.length > 0 && Math.random() < state.networkComplexity) {
          chosenPair = ambiguousPairs[Math.floor(Math.random() * ambiguousPairs.length)];
        } else if (stimuli.length < numStimuli) {
          const newStimulus = generateStimulus();
          stimuli.push(newStimulus);
          chosenPair = { s1: stimuli[Math.floor(Math.random() * (stimuli.length - 1))], s2: newStimulus };
        } else {
          const availablePairs = [];
          for (let i = 0; i < stimuli.length; i++) {
            for (let j = i + 1; j < stimuli.length; j++) {
              const s1 = stimuli[i], s2 = stimuli[j];
              if (!premises.some(pr => (pr.stimulus1 === s1 && pr.stimulus2 === s2) || (pr.stimulus1 === s2 && pr.stimulus2 === s1))) {
                availablePairs.push({ s1, s2 });
              }
            }
          }
          chosenPair = availablePairs.length > 0 ? availablePairs[Math.floor(Math.random() * availablePairs.length)] : { s1: stimuli[0], s2: stimuli[1] };
        }
        if (chosenPair) premises.push({ stimulus1: chosenPair.s1, relation: activeRelations[Math.floor(Math.random() * activeRelations.length)], stimulus2: chosenPair.s2 });
      }
      
      const startIdx = Math.floor(Math.random() * stimuli.length);
      let endIdx = Math.floor(Math.random() * stimuli.length);
      if (startIdx === endIdx) endIdx = (endIdx + 1) % stimuli.length;
      const derivedRelation = deriveRelationFromGraph(premises, stimuli[startIdx], stimuli[endIdx]);
      let questionRelation, correctAnswer;
      
      if (derivedRelation === 'AMBIGUOUS' || derivedRelation === null) {
        questionRelation = activeRelations[Math.floor(Math.random() * activeRelations.length)];
        correctAnswer = 'ambiguous';
      } else {
        const askCompatible = Math.random() < 0.5;
        if (askCompatible) {
          questionRelation = derivedRelation;
          correctAnswer = true;
        } else {
          const incompatible = activeRelations.filter(r => r !== derivedRelation);
          if (incompatible.length > 0) {
            questionRelation = incompatible[Math.floor(Math.random() * incompatible.length)];
            correctAnswer = false;
          } else {
            questionRelation = derivedRelation;
            correctAnswer = true;
          }
        }
      }

      return { premises, question: { stimulus1: stimuli[startIdx], relation: questionRelation, stimulus2: stimuli[endIdx] }, correctAnswer, derivedRelation: derivedRelation || 'AMBIGUOUS', allPaths: findAllPaths(premises, stimuli[startIdx], stimuli[endIdx]), allStimuli: stimuli };
    };

    const startNewTrial = () => {
      state.currentTrial = generateTrial();
      state.timeLeft = state.timePerQuestion;
      state.feedback = null;
      render();
    };

    const saveToStorage = async () => {
      try {
        await window.storage.set('rft-data', JSON.stringify({ 
          score: state.score, 
          history: state.history, 
          statsHistory: state.statsHistory, 
          settings: { 
            difficulty: state.difficulty, 
            timePerQuestion: state.timePerQuestion, 
            networkComplexity: state.networkComplexity, 
            spoilerPremises: state.spoilerPremises, 
            darkMode: state.darkMode, 
            useLetters: state.useLetters, 
            useEmojis: state.useEmojis, 
            useVoronoi: state.useVoronoi, 
            letterLength: state.letterLength, 
            autoProgressEnabled: state.autoProgressEnabled, 
            targetPremiseCount: state.targetPremiseCount, 
            targetAccuracy: state.targetAccuracy, 
            enabledRelationModes: state.enabledRelationModes 
          }, 
          recentAnswers: state.recentAnswers 
        }));
      } catch (error) {
        console.error('Save failed:', error);
      }
    };

    const loadFromStorage = async () => {
      try {
        const result = await window.storage.get('rft-data');
        if (result?.value) {
          const data = JSON.parse(result.value);
          if (data.score) state.score = data.score;
          if (data.history) state.history = data.history;
          if (data.statsHistory) state.statsHistory = data.statsHistory;
          if (data.recentAnswers) state.recentAnswers = data.recentAnswers;
          if (data.settings) {
            Object.assign(state, data.settings);
          }
        }
      } catch (error) {
        console.log('No saved data found');
      }
    };

    const resetGame = () => {
      state.score = { correct: 0, incorrect: 0, missed: 0 };
      state.history = [];
      state.recentAnswers = [];
      state.statsHistory = [];
      startNewTrial();
      saveToStorage();
    };

    const getAnswerLabel = (answer) => {
      if (answer === true) return 'YES';
      if (answer === false) return 'NO';
      if (answer === 'ambiguous') return "CAN'T TELL";
      return 'NO ANSWER';
    };

    const checkAutoProgress = (updatedAnswers) => {
      if (!state.autoProgressEnabled || updatedAnswers.length < state.targetPremiseCount) return;
      const recentWindow = updatedAnswers.slice(-state.targetPremiseCount);
      const accuracy = (recentWindow.filter(a => a).length / state.targetPremiseCount) * 100;
      if (accuracy >= state.targetAccuracy) {
        if (state.timePerQuestion > 10) {
          const newTime = Math.max(10, state.timePerQuestion - 5);
          state.timePerQuestion = newTime;
          if (newTime === 10) {
            state.difficulty += 1;
            state.timePerQuestion = 30;
            state.recentAnswers = [];
          }
        } else {
          state.difficulty += 1;
          state.timePerQuestion = 30;
          state.recentAnswers = [];
        }
      }
    };

    const handleAnswer = (userAnswer) => {
      if (state.isPaused || state.feedback) return;
      const isCorrect = userAnswer === state.currentTrial.correctAnswer;
      const timeUsed = state.timePerQuestion - state.timeLeft;
      state.score.correct += isCorrect ? 1 : 0;
      state.score.incorrect += isCorrect ? 0 : 1;
      state.feedback = isCorrect ? 'correct' : 'incorrect';
      const entry = { trial: state.currentTrial, userAnswer, isCorrect, timestamp: Date.now(), timeUsed, premiseCount: state.currentTrial.premises.length };
      state.history.push(entry);
      state.statsHistory.push({ timestamp: Date.now(), timeUsed, premiseCount: state.currentTrial.premises.length, isCorrect });
      const updatedAnswers = [...state.recentAnswers, isCorrect];
      state.recentAnswers = updatedAnswers;
      checkAutoProgress(updatedAnswers);
      render();
      setTimeout(() => { startNewTrial(); saveToStorage(); }, 1500);
    };

    const togglePause = () => {
      state.isPaused = !state.isPaused;
      if (!state.isPaused) {
        state.currentTrial = generateTrial();
        state.feedback = null;
      } else {
        state.timeLeft = state.timePerQuestion;
      }
      render();
    };

    const startTimer = () => {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (!state.isPaused && !state.feedback && state.timeLeft > 0) {
          state.timeLeft = Math.max(0, state.timeLeft - 0.1);
          document.querySelector('#timer-display')?.innerText = state.timeLeft.toFixed(1) + 's';
          const progressBar = document.querySelector('#progress-bar');
          if (progressBar) {
            progressBar.style.width = `${(state.timeLeft / state.timePerQuestion) * 100}%`;
          }
        } else if (!state.isPaused && !state.feedback && state.timeLeft <= 0) {
          const timeUsed = state.timePerQuestion;
          state.score.missed += 1;
          state.feedback = 'missed';
          state.history.push({ trial: state.currentTrial, userAnswer: null, isCorrect: false, timestamp: Date.now(), timeUsed, premiseCount: state.currentTrial.premises.length });
          state.statsHistory.push({ timestamp: Date.now(), timeUsed, premiseCount: state.currentTrial.premises.length, isCorrect: false });
          render();
          setTimeout(() => { startNewTrial(); saveToStorage(); }, 1500);
        }
      }, 100);
    };

    const renderStimulus = (stimulus) => {
      if (stimulus.startsWith('voronoi_')) {
        return `<div class="inline-block w-16 h-16 align-middle">${generateVoronoiSVG(parseInt(stimulus.split('_')[1]))}</div>`;
      }
      const isEmoji = emojiList.includes(stimulus);
      return `<span class="font-bold ${isEmoji ? 'text-3xl' : ''} ${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">${stimulus}</span>`;
    };

    const getRelationColor = (relation) => {
      if (state.darkMode) {
        if (relation === 'SAME') return 'bg-green-900/40 text-green-300 border-green-500';
        if (relation === 'OPPOSITE') return 'bg-red-900/40 text-red-300 border-red-500';
        if (relation === 'DIFFERENT') return 'bg-blue-900/40 text-blue-300 border-blue-500';
        if (relation === 'BEFORE') return 'bg-purple-900/40 text-purple-300 border-purple-500';
        if (relation === 'AFTER') return 'bg-orange-900/40 text-orange-300 border-orange-500';
        if (relation === 'AT') return 'bg-cyan-900/40 text-cyan-300 border-cyan-500';
        if (['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'].includes(relation)) {
          return 'bg-teal-900/40 text-teal-300 border-teal-500';
        }
        return 'bg-blue-900/40 text-blue-300 border-blue-500';
      }
      
      if (relation === 'SAME') return 'bg-green-100 text-green-700 border-green-300';
      if (relation === 'OPPOSITE') return 'bg-red-100 text-red-700 border-red-300';
      if (relation === 'DIFFERENT') return 'bg-blue-100 text-blue-700 border-blue-300';
      if (relation === 'BEFORE') return 'bg-purple-100 text-purple-700 border-purple-300';
      if (relation === 'AFTER') return 'bg-orange-100 text-orange-700 border-orange-300';
      if (relation === 'AT') return 'bg-cyan-100 text-cyan-700 border-cyan-300';
      if (['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'].includes(relation)) {
        return 'bg-teal-100 text-teal-700 border-teal-300';
      }
      if (['CONTAINS', 'WITHIN'].includes(relation)) {
        return 'bg-amber-100 text-amber-700 border-amber-300';
      }
      return 'bg-blue-100 text-blue-700 border-blue-300';
    };

    // Icons as SVG
    const icons = {
      settings: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m0-6h6m-6 0H6m9.364-7.364L12 6.364m0 0L8.636 9.636m3.364-3.272L8.636 2.636m6.728 18.728L12 17.636m0 0l-3.364-3.364m3.364 3.364l3.364 3.364"></path></svg>',
      history: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path><path d="M12 7v5l4 2"></path></svg>',
      play: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>',
      pause: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>',
      reset: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path></svg>',
      x: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
      check: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>',
      clock: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>',
      trending: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline></svg>',
      info: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>'
    };

    // Render function
    const render = () => {
      const app = document.getElementById('app');
      
      const bgClass = state.darkMode ? 'bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900' : 'bg-gradient-to-br from-slate-50 to-slate-100';
      
      app.innerHTML = `
        <div class="min-h-screen flex flex-col smooth-transition ${bgClass}">
          
          ${state.showTutorial ? `
            <div class="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-2 sm:p-4" onclick="closeTutorial(event)">
              <div class="max-w-2xl w-full rounded-2xl p-4 sm:p-6 shadow-2xl max-h-[90vh] overflow-y-auto ${state.darkMode ? 'bg-slate-800' : 'bg-white'}">
                <div class="flex justify-between items-center mb-4">
                  <h2 class="text-xl sm:text-2xl font-bold ${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">How to Play</h2>
                  <button onclick="closeTutorialButton()" class="p-2 rounded-lg ${state.darkMode ? 'hover:bg-slate-700' : 'hover:bg-gray-100'}">
                    ${icons.x}
                  </button>
                </div>
                <div class="space-y-3 sm:space-y-4 text-sm sm:text-base ${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">
                  <p><strong class="${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">Relational Frame Training</strong> helps you practice deriving logical relationships between stimuli.</p>
                  <div>
                    <h3 class="font-bold mb-2 ${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">Game Rules:</h3>
                    <ul class="list-disc pl-5 sm:pl-6 space-y-1 sm:space-y-2">
                      <li>You will be given several <strong>premises</strong> that establish relationships between stimuli</li>
                      <li>Based on these premises, you must answer whether a <strong>question relationship</strong> is true</li>
                      <li>Answer <strong>YES</strong> if the relationship follows from the premises</li>
                      <li>Answer <strong>NO</strong> if the relationship contradicts the premises</li>
                      <li>Answer <strong>CAN'T TELL</strong> if there is insufficient information or contradictions</li>
                    </ul>
                  </div>
                  <div>
                    <h3 class="font-bold mb-2 ${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">Keyboard Shortcuts:</h3>
                    <ul class="list-disc pl-6 space-y-2">
                      <li><kbd class="px-2 py-1 rounded ${state.darkMode ? 'bg-slate-700' : 'bg-gray-200'}">1</kbd> - Answer YES</li>
                      <li><kbd class="px-2 py-1 rounded ${state.darkMode ? 'bg-slate-700' : 'bg-gray-200'}">2</kbd> - Answer NO</li>
                      <li><kbd class="px-2 py-1 rounded ${state.darkMode ? 'bg-slate-700' : 'bg-gray-200'}">3</kbd> - Answer CAN'T TELL</li>
                      <li><kbd class="px-2 py-1 rounded ${state.darkMode ? 'bg-slate-700' : 'bg-gray-200'}">Space</kbd> - Pause/Resume</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          ` : ''}

          ${state.showHistory || state.showStats ? `
            <div class="sm:hidden fixed inset-0 z-40 bg-black/50 backdrop-blur-sm" onclick="closeHistoryStats()"></div>
          ` : ''}

          <div class="smooth-transition overflow-hidden ${state.showHistory ? 'fixed sm:relative inset-y-0 left-0 w-[90vw] sm:w-96 z-50' : 'w-0'} ${state.darkMode ? 'bg-slate-800' : 'bg-white'} shadow-xl">
            ${state.showHistory ? `
              <div class="h-full flex flex-col p-3 sm:p-4">
                <div class="flex items-center justify-between mb-3 sm:mb-4">
                  <div class="flex items-center">
                    <div class="w-4 h-4 sm:w-5 sm:h-5 mr-2 ${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">${icons.history}</div>
                    <h2 class="text-base sm:text-lg font-bold ${state.darkMode ? 'text-gray-100' : 'text-gray-800'}">History</h2>
                  </div>
                  <button onclick="closeTutorialButton()" class="p-1.5 sm:p-1 rounded ${state.darkMode ? 'hover:bg-slate-700' : 'hover:bg-gray-100'}">
                    ${icons.x}
                  </button>
                </div>
                <div class="flex-1 overflow-y-auto space-y-2 sm:space-y-3">
                  ${state.history.length === 0 ? `
                    <p class="text-xs sm:text-sm ${state.darkMode ? 'text-gray-400' : 'text-gray-500'}">No questions answered yet</p>
                  ` : state.history.slice().reverse().map((item, idx) => `
                    <div class="p-2.5 sm:p-3 rounded-lg border-2 ${state.darkMode ? (item.isCorrect ? 'border-green-500/50 bg-green-900/20' : 'border-red-500/50 bg-red-900/20') : (item.isCorrect ? 'border-green-300 bg-green-50' : 'border-red-300 bg-red-50')}">
                      <div class="text-xs font-semibold mb-1.5 sm:mb-2 ${state.darkMode ? 'text-gray-400' : 'text-gray-500'}">
                        Question #${state.history.length - idx} â€¢ ${item.timeUsed.toFixed(1)}s
                      </div>
                      <div class="text-xs space-y-0.5 sm:space-y-1">
                        <div class="${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">
                          <span class="font-semibold">Your answer:</span> <span class="${item.isCorrect ? (state.darkMode ? 'text-green-400' : 'text-green-700') : (state.darkMode ? 'text-red-400' : 'text-red-700')}">${getAnswerLabel(item.userAnswer)}</span>
                        </div>
                        <div class="${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">
                          <span class="font-semibold">Correct:</span> <span class="${state.darkMode ? 'text-green-400' : 'text-green-700'}">${getAnswerLabel(item.trial.correctAnswer)}</span>
                        </div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
          </div>

          <div class="smooth-transition overflow-hidden ${state.showStats ? 'fixed sm:relative inset-y-0 left-0 w-[90vw] sm:w-96 z-50' : 'w-0'} ${state.darkMode ? 'bg-slate-800' : 'bg-white'} shadow-xl">
            ${state.showStats ? `
              <div class="h-full flex flex-col p-3 sm:p-4">
                <div class="flex items-center justify-between mb-3 sm:mb-4">
                  <div class="flex items-center">
                    <div class="w-4 h-4 sm:w-5 sm:h-5 mr-2 ${state.darkMode ? 'text-purple-400' : 'text-purple-600'}">${icons.trending}</div>
                    <h2 class="text-base sm:text-lg font-bold ${state.darkMode ? 'text-gray-100' : 'text-gray-800'}">Statistics</h2>
                  </div>
                  <button onclick="closeStats()" class="p-1.5 sm:p-1 rounded ${state.darkMode ? 'hover:bg-slate-700' : 'hover:bg-gray-100'}">
                    ${icons.x}
                  </button>
                </div>
                <div class="flex-1 overflow-y-auto space-y-4 sm:space-y-6">
                  ${state.statsHistory.length === 0 ? `
                    <p class="text-xs sm:text-sm ${state.darkMode ? 'text-gray-400' : 'text-gray-500'}">No statistics yet</p>
                  ` : `
                    <div class="p-3 sm:p-4 rounded-lg ${state.darkMode ? 'bg-slate-700' : 'bg-gray-50'}">
                      <h3 class="text-xs sm:text-sm font-semibold mb-2 sm:mb-3 ${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">Overall</h3>
                      <div class="space-y-1.5 sm:space-y-2">
                        <div class="flex justify-between">
                          <span class="text-xs sm:text-sm ${state.darkMode ? 'text-gray-400' : 'text-gray-600'}">Total Questions:</span>
                          <span class="text-xs sm:text-sm font-bold ${state.darkMode ? 'text-gray-200' : 'text-gray-800'}">${state.statsHistory.length}</span>
                        </div>
                        <div class="flex justify-between">
                          <span class="text-xs sm:text-sm ${state.darkMode ? 'text-gray-400' : 'text-gray-600'}">Accuracy:</span>
                          <span class="text-xs sm:text-sm font-bold ${state.darkMode ? 'text-green-400' : 'text-green-600'}">
                            ${((state.statsHistory.filter(s => s.isCorrect).length / state.statsHistory.length) * 100).toFixed(1)}%
                          </span>
                        </div>
                      </div>
                    </div>
                  `}
                </div>
              </div>
            ` : ''}
          </div>

          <div class="flex-1 flex flex-col min-h-0">
            <div class="shadow-md p-2 sm:p-3 flex flex-col gap-2 smooth-transition ${state.darkMode ? 'bg-slate-800/90 backdrop-blur' : 'bg-white'}">
              <div class="flex justify-between items-center gap-2">
                <div class="flex gap-1 sm:gap-2">
                  <button onclick="toggleHistory()" class="flex items-center gap-1 px-2 sm:px-3 py-1.5 sm:py-2 rounded-lg smooth-transition text-xs sm:text-sm ${state.darkMode ? 'bg-indigo-900/50 hover:bg-indigo-900/70 text-indigo-200' : 'bg-indigo-100 hover:bg-indigo-200 text-gray-900'}">
                    <span class="w-4 h-4">${icons.history}</span>
                    <span class="hidden sm:inline">History</span>
                  </button>
                  
                  <button onclick="toggleStats()" class="flex items-center gap-1 px-2 sm:px-3 py-1.5 sm:py-2 rounded-lg smooth-transition text-xs sm:text-sm ${state.darkMode ? 'bg-purple-900/50 hover:bg-purple-900/70 text-purple-200' : 'bg-purple-100 hover:bg-purple-200 text-gray-900'}">
                    <span class="w-4 h-4">${icons.trending}</span>
                    <span class="hidden sm:inline">Stats</span>
                  </button>

                  <button onclick="toggleTutorial()" class="flex items-center gap-1 px-2 sm:px-3 py-1.5 sm:py-2 rounded-lg smooth-transition text-xs sm:text-sm ${state.darkMode ? 'bg-cyan-900/50 hover:bg-cyan-900/70 text-cyan-200' : 'bg-cyan-100 hover:bg-cyan-200 text-gray-900'}">
                    <span class="w-4 h-4">${icons.info}</span>
                    <span class="hidden sm:inline">Help</span>
                  </button>
                </div>
                
                <div class="flex items-center gap-2 sm:gap-3">
                  <div class="text-center">
                    <div id="timer-display" class="text-base sm:text-xl font-bold tabular-nums ${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">${state.timeLeft.toFixed(1)}s</div>
                    <div class="text-xs hidden sm:block ${state.darkMode ? 'text-gray-400' : 'text-gray-600'}">Time</div>
                  </div>
                  <button onclick="togglePause();" class="text-white p-1.5 sm:p-2 rounded-lg smooth-transition ${state.isPaused ? 'bg-green-500 hover:bg-green-600' : (state.darkMode ? 'bg-yellow-600 hover:bg-yellow-700' : 'bg-yellow-500 hover:bg-yellow-600')}">
                    <span class="w-4 h-4 sm:w-5 sm:h-5 inline-block">${state.isPaused ? icons.play : icons.pause}</span>
                  </button>
                  <button onclick="resetGame();" class="p-1.5 sm:p-2 rounded-lg smooth-transition ${state.darkMode ? 'bg-slate-700 hover:bg-slate-600 text-gray-300' : 'bg-gray-200 hover:bg-gray-300'}">
                    <span class="w-4 h-4 sm:w-5 sm:h-5 inline-block ${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">${icons.reset}</span>
                  </button>
                  <button onclick="toggleSettings()" class="flex items-center gap-1 px-2 sm:px-3 py-1.5 sm:py-2 rounded-lg smooth-transition text-xs sm:text-sm ${state.darkMode ? 'bg-indigo-900/50 hover:bg-indigo-900/70 text-indigo-200' : 'bg-indigo-100 hover:bg-indigo-200 text-gray-900'}">
                    <span class="w-4 h-4">${icons.settings}</span>
                    <span class="hidden sm:inline">Settings</span>
                  </button>
                </div>
              </div>
              
              <div class="flex gap-2 sm:gap-4 justify-center sm:justify-start">
                <div class="text-center">
                  <div class="text-base sm:text-xl font-bold ${state.darkMode ? 'text-green-400' : 'text-green-600'}">${state.score.correct}</div>
                  <div class="text-xs ${state.darkMode ? 'text-gray-400' : 'text-gray-600'}">Correct</div>
                </div>
                <div class="text-center">
                  <div class="text-base sm:text-xl font-bold ${state.darkMode ? 'text-red-400' : 'text-red-600'}">${state.score.incorrect}</div>
                  <div class="text-xs ${state.darkMode ? 'text-gray-400' : 'text-gray-600'}">Incorrect</div>
                </div>
                <div class="text-center">
                  <div class="text-base sm:text-xl font-bold ${state.darkMode ? 'text-orange-400' : 'text-orange-600'}">${state.score.missed}</div>
                  <div class="text-xs ${state.darkMode ? 'text-gray-400' : 'text-gray-600'}">Missed</div>
                </div>
              </div>
            </div>

            <div class="shadow-sm p-1 sm:p-2 smooth-transition ${state.darkMode ? 'bg-slate-800/50' : 'bg-white'}">
              <div class="h-2 sm:h-3 rounded-full overflow-hidden ${state.darkMode ? 'bg-slate-700' : 'bg-gray-200'}">
                <div id="progress-bar" class="h-full smooth-transition ${state.isPaused ? (state.darkMode ? 'bg-yellow-600' : 'bg-yellow-500') : (state.darkMode ? 'bg-indigo-500' : 'bg-indigo-600')}" style="width: ${(state.timeLeft / state.timePerQuestion) * 100}%"></div>
              </div>
            </div>

            <div class="flex-1 overflow-y-auto p-3 sm:p-6">
              <div class="max-w-4xl mx-auto">
                ${state.isPaused ? `
                  <div class="border-2 rounded-xl p-4 sm:p-6 mb-4 sm:mb-6 text-center smooth-transition ${state.darkMode ? 'bg-yellow-900/20 border-yellow-500/50 backdrop-blur' : 'bg-yellow-50 border-yellow-300'}">
                    <div class="w-10 h-10 sm:w-12 sm:h-12 mx-auto mb-2 ${state.darkMode ? 'text-yellow-400' : 'text-yellow-600'}">${icons.pause}</div>
                    <h2 class="text-xl sm:text-2xl font-bold mb-2 ${state.darkMode ? 'text-yellow-300' : 'text-yellow-800'}">Paused</h2>
                    <p class="text-sm sm:text-base ${state.darkMode ? 'text-yellow-200' : 'text-yellow-700'}">
                      Press <kbd class="px-2 sm:px-3 py-1 rounded font-mono text-xs sm:text-sm ${state.darkMode ? 'bg-slate-700 text-yellow-300' : 'bg-white'}">Space</kbd> or the play button to resume
                    </p>
                  </div>
                ` : state.currentTrial ? `
                  <div class="rounded-xl sm:rounded-2xl shadow-xl p-4 sm:p-8 smooth-transition ${state.darkMode ? 'bg-slate-800/90 backdrop-blur' : 'bg-white'}">
                    <h3 class="text-xs sm:text-sm font-semibold uppercase tracking-wide mb-3 sm:mb-4 ${state.darkMode ? 'text-gray-400' : 'text-gray-500'}">Given:</h3>
                    <div class="space-y-2 sm:space-y-3 mb-6 sm:mb-8">
                      ${state.currentTrial.premises.map((premise, idx) => `
                        <div class="relative flex items-center justify-center text-base sm:text-xl p-3 sm:p-4 rounded-lg overflow-hidden smooth-transition ${state.darkMode ? 'bg-slate-700/50' : 'bg-gray-50'}">
                          <div class="relative z-0 flex items-center gap-1.5 sm:gap-2 flex-wrap justify-center">
                            ${renderStimulus(premise.stimulus1)}
                            <span class="mx-1 text-sm sm:text-base ${state.darkMode ? 'text-gray-500' : 'text-gray-400'}">is</span>
                            <span class="font-semibold px-2 sm:px-3 py-0.5 sm:py-1 rounded border text-sm sm:text-base ${getRelationColor(premise.relation)}">${premise.relation}</span>
                            <span class="mx-1 text-sm sm:text-base ${state.darkMode ? 'text-gray-500' : 'text-gray-400'}">to</span>
                            ${renderStimulus(premise.stimulus2)}
                          </div>
                          ${state.spoilerPremises && state.hoveredPremise !== idx ? `
                            <div class="absolute inset-0 rounded-lg z-10 ${state.darkMode ? 'bg-gradient-to-r from-purple-600 via-pink-600 to-indigo-600' : 'bg-gradient-to-r from-indigo-400 via-purple-400 to-pink-400'}"></div>
                          ` : ''}
                        </div>
                      `).join('')}
                    </div>

                    <div class="border-t-4 pt-6 sm:pt-8 ${state.feedback === 'correct' ? (state.darkMode ? 'border-green-500' : 'border-green-500') : state.feedback === 'incorrect' ? (state.darkMode ? 'border-red-500' : 'border-red-500') : state.feedback === 'missed' ? (state.darkMode ? 'border-orange-500' : 'border-orange-500') : (state.darkMode ? 'border-indigo-500' : 'border-indigo-500')}">
                      <h3 class="text-base sm:text-lg font-semibold mb-3 sm:mb-4 ${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">Question:</h3>
                      <div class="flex items-center justify-center text-lg sm:text-2xl p-4 sm:p-6 rounded-xl mb-4 sm:mb-6 smooth-transition gap-1.5 sm:gap-2 flex-wrap ${state.darkMode ? 'bg-indigo-900/30' : 'bg-indigo-50'}">
                        <span class="font-bold text-base sm:text-2xl ${state.darkMode ? 'text-indigo-300' : 'text-indigo-700'}">Is</span>
                        ${renderStimulus(state.currentTrial.question.stimulus1)}
                        <span class="mx-1 sm:mx-2 font-semibold px-3 sm:px-4 py-1 sm:py-2 rounded-lg border-2 text-sm sm:text-base ${getRelationColor(state.currentTrial.question.relation)}">${state.currentTrial.question.relation}</span>
                        ${getRelationMode(state.currentTrial.question.relation) === 'equality' ? '<span class="font-bold text-base sm:text-2xl ' + (state.darkMode ? 'text-indigo-300' : 'text-indigo-700') + '">to</span>' : ''}
                        ${renderStimulus(state.currentTrial.question.stimulus2)}
                        <span class="font-bold text-base sm:text-2xl ${state.darkMode ? 'text-indigo-300' : 'text-indigo-700'}">?</span>
                      </div>

                      ${state.feedback ? `
                        <div class="text-center text-xl sm:text-2xl font-bold mb-4 sm:mb-6 ${state.feedback === 'correct' ? (state.darkMode ? 'text-green-400' : 'text-green-600') : state.feedback === 'incorrect' ? (state.darkMode ? 'text-red-400' : 'text-red-600') : (state.darkMode ? 'text-orange-400' : 'text-orange-600')}">
                          <span class="inline-block w-6 h-6 sm:w-8 sm:h-8 mr-2 align-middle">${state.feedback === 'correct' ? icons.check : state.feedback === 'incorrect' ? icons.x : icons.clock}</span>
                          ${state.feedback === 'correct' ? 'Correct!' : state.feedback === 'incorrect' ? 'Incorrect' : 'Time\'s Up!'}
                        </div>
                      ` : `
                        <div class="flex flex-col gap-3 sm:gap-4">
                          <button onclick="handleAnswer(true);" class="w-full px-6 py-3 sm:py-4 text-white text-lg sm:text-xl font-bold rounded-xl smooth-transition transform active:scale-95 sm:hover:scale-105 ${state.darkMode ? 'bg-green-600 hover:bg-green-700 shadow-lg shadow-green-900/50' : 'bg-green-500 hover:bg-green-600'}">
                            YES <span class="text-sm">(1)</span>
                          </button>
                          <button onclick="handleAnswer(false);" class="w-full px-6 py-3 sm:py-4 text-white text-lg sm:text-xl font-bold rounded-xl smooth-transition transform active:scale-95 sm:hover:scale-105 ${state.darkMode ? 'bg-red-600 hover:bg-red-700 shadow-lg shadow-red-900/50' : 'bg-red-500 hover:bg-red-600'}">
                            NO <span class="text-sm">(2)</span>
                          </button>
                          <button onclick="handleAnswer('ambiguous');" class="w-full px-6 py-3 sm:py-4 text-white text-lg sm:text-xl font-bold rounded-xl smooth-transition transform active:scale-95 sm:hover:scale-105 ${state.darkMode ? 'bg-slate-600 hover:bg-slate-700 shadow-lg shadow-slate-900/50' : 'bg-gray-500 hover:bg-gray-600'}">
                            CAN'T TELL <span class="text-sm">(3)</span>
                          </button>
                        </div>
                      `}
                    </div>
                  </div>
                ` : ''}
              </div>
            </div>
          </div>

          ${state.showSettings ? `
            <div class="sm:hidden fixed inset-0 z-40 bg-black/50 backdrop-blur-sm" onclick="closeSettings()"></div>
          ` : ''}
          
          <div class="smooth-transition overflow-hidden ${state.showSettings ? 'fixed sm:relative inset-y-0 right-0 w-[90vw] sm:w-96 z-50' : 'w-0'} ${state.darkMode ? 'bg-slate-800' : 'bg-white'} shadow-xl">
            ${state.showSettings ? `
              <div class="h-full flex flex-col p-3 sm:p-4">
                <div class="flex items-center justify-between mb-3 sm:mb-4">
                  <div class="flex items-center">
                    <div class="w-4 h-4 sm:w-5 sm:h-5 mr-2 ${state.darkMode ? 'text-indigo-400' : 'text-indigo-600'}">${icons.settings}</div>
                    <h2 class="text-base sm:text-lg font-bold ${state.darkMode ? 'text-gray-100' : 'text-gray-800'}">Settings</h2>
                  </div>
                  <button onclick="closeSettings()" class="p-1.5 sm:p-1 rounded ${state.darkMode ? 'hover:bg-slate-700' : 'hover:bg-gray-100'}">
                    ${icons.x}
                  </button>
                </div>
                
                <div class="flex-1 overflow-y-auto space-y-4 sm:space-y-6">
                  <div>
                    <label class="block text-sm font-semibold mb-2 ${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">Dark Mode</label>
                    <button onclick="toggleDarkMode()" class="w-full flex items-center justify-between">
                      <div class="relative w-14 h-7 rounded-full smooth-transition ${state.darkMode ? 'bg-indigo-600' : 'bg-gray-300'}">
                        <div class="absolute top-0.5 left-0.5 w-6 h-6 bg-white rounded-full smooth-transition shadow-md ${state.darkMode ? 'transform translate-x-7' : ''}"></div>
                      </div>
                      <span class="text-sm font-medium ${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">${state.darkMode ? 'Enabled' : 'Disabled'}</span>
                    </button>
                  </div>

                  <div>
                    <label class="block text-sm font-semibold mb-2 ${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">Premise Count</label>
                    <input type="number" min="2" max="20" value="${state.difficulty}" onchange="updateDifficulty(this.value)" class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent smooth-transition ${state.darkMode ? 'bg-slate-700 border-slate-600 text-gray-100' : 'bg-white border-gray-300 text-gray-900'}" />
                  </div>

                  <div>
                    <label class="block text-sm font-semibold mb-2 ${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">Time Per Question (seconds): ${state.timePerQuestion.toFixed(1)}</label>
                    <input type="range" min="5" max="120" step="0.5" value="${state.timePerQuestion}" oninput="updateTimePerQuestion(this.value)" class="w-full" />
                  </div>

                  <div>
                    <label class="flex items-center space-x-2 cursor-pointer">
                      <input type="checkbox" ${state.spoilerPremises ? 'checked' : ''} onchange="updateSpoilerPremises(this.checked)" class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                      <span class="text-sm font-semibold ${state.darkMode ? 'text-gray-300' : 'text-gray-700'}">Spoiler Premises</span>
                    </label>
                  </div>
                </div>
              </div>
            ` : ''}
          </div>
        </div>
      `;

      // Add hover listeners for spoiler premises
      if (state.spoilerPremises && state.currentTrial) {
        setTimeout(() => {
          state.currentTrial.premises.forEach((_, idx) => {
            const premiseEl = document.querySelectorAll('.relative.flex.items-center.justify-center')[idx];
            if (premiseEl) {
              premiseEl.addEventListener('mouseenter', () => {
                state.hoveredPremise = idx;
                render();
              });
              premiseEl.addEventListener('mouseleave', () => {
                state.hoveredPremise = null;
                render();
              });
            }
          });
        }, 0);
      }
    };

    // Event handlers
    window.togglePause = togglePause;
    window.resetGame = resetGame;
    window.handleAnswer = handleAnswer;
    window.saveToStorage = saveToStorage;
    
    window.updateDifficulty = (value) => {
      state.difficulty = Math.max(2, parseInt(value) || 2);
      saveToStorage();
      render();
    };
    
    window.updateTimePerQuestion = (value) => {
      state.timePerQuestion = parseFloat(value);
      saveToStorage();
      render();
    };
    
    window.updateSpoilerPremises = (checked) => {
      state.spoilerPremises = checked;
      saveToStorage();
      render();
    };
    
    window.toggleDarkMode = () => {
      state.darkMode = !state.darkMode;
      saveToStorage();
      render();
    };
    
    window.toggleHistory = () => {
      state.showHistory = !state.showHistory;
      render();
    };
    
    window.toggleStats = () => {
      state.showStats = !state.showStats;
      render();
    };
    
    window.toggleTutorial = () => {
      state.showTutorial = !state.showTutorial;
      render();
    };
    
    window.toggleSettings = () => {
      state.showSettings = !state.showSettings;
      render();
    };
    
    window.closeTutorial = (event) => {
      if (event.target === event.currentTarget) {
        state.showTutorial = false;
        render();
      }
    };
    
    window.closeTutorialButton = () => {
      state.showTutorial = false;
      render();
    };
    
    window.closeHistoryStats = () => {
      state.showHistory = false;
      state.showStats = false;
      render();
    };
    
    window.closeHistory = () => {
      state.showHistory = false;
      render();
    };
    
    window.closeStats = () => {
      state.showStats = false;
      render();
    };
    
    window.closeSettings = () => {
      state.showSettings = false;
      render();
    };

    // Keyboard event listener
    document.addEventListener('keydown', (e) => {
      if (e.key === ' ') {
        e.preventDefault();
        togglePause();
      } else if (!state.isPaused && !state.feedback) {
        if (e.key === '1') handleAnswer(true);
        else if (e.key === '2') handleAnswer(false);
        else if (e.key === '3') handleAnswer('ambiguous');
      }
    });

    // Initialize
    (async () => {
      await loadFromStorage();
      startNewTrial();
      startTimer();
      render();
    })();
  </script>
</body>
</html>
