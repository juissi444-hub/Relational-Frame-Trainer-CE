<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Relational Frame Trainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body { 
            margin: 0; 
            font-family: system-ui, -apple-system, sans-serif; 
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        .emoji-stimulus { font-size: 2rem; line-height: 1; }
        input[type="range"] { 
            -webkit-appearance: none; 
            width: 100%;
            height: 8px; 
            border-radius: 5px; 
            background: #ddd; 
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            width: 24px; 
            height: 24px; 
            border-radius: 50%; 
            background: #6366f1; 
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb { 
            width: 24px; 
            height: 24px; 
            border-radius: 50%; 
            background: #6366f1; 
            cursor: pointer; 
            border: none;
        }
        .dark input[type="range"] { background: #475569; }
        button { cursor: pointer; }
        button:active { transform: scale(0.95); }
        @media (max-width: 640px) {
            button { min-height: 44px; min-width: 44px; }
        }
    </style>
</head>
<body>
    <div id="app">
        <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background: #f9fafb;">
            <div style="text-align: center;">
                <div style="width: 64px; height: 64px; border: 4px solid #e5e7eb; border-top-color: #6366f1; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                <p style="margin-top: 16px; color: #6b7280;">Initializing...</p>
            </div>
        </div>
    </div>

    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>

    <script>
        console.log('Script starting...');

        // Global state
        const state = {
            timePerQuestion: 30,
            networkComplexity: 0.5,
            spoilerPremises: false,
            darkMode: false,
            useLetters: true,
            useEmojis: false,
            useVoronoi: false,
            useMandelbrot: false,
            letterLength: 3,
            autoProgressEnabled: true,
            universalAutoProgress: true,
            targetPremiseCount: 40,
            targetAccuracy: 95,
            recentAnswers: [],
            statsHistory: [],
            showSettings: false,
            showHistory: false,
            showStats: false,
            isPaused: false,
            currentTrial: null,
            timeLeft: 30,
            score: { correct: 0, incorrect: 0, missed: 0 },
            feedback: null,
            history: [],
            enabledRelationModes: {
                equality: true,
                temporal: false,
                spatial: false,
                containment: false
            },
            premiseCounts: {
                equality: 3,
                temporal: 3,
                spatial: 3,
                containment: 3
            },
            modeProgress: {
                equality: { recentAnswers: [], timePerQuestion: 30 },
                temporal: { recentAnswers: [], timePerQuestion: 30 },
                spatial: { recentAnswers: [], timePerQuestion: 30 },
                containment: { recentAnswers: [], timePerQuestion: 30 }
            }
        };

        const relationSets = {
            equality: ['SAME', 'OPPOSITE', 'DIFFERENT'],
            temporal: ['BEFORE', 'AFTER', 'AT'],
            spatial: ['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'],
            containment: ['CONTAINS', 'WITHIN']
        };

        const emojiList = ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó', 'üòö', 'üòô', 'ü•≤', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î'];

        let timerId = null;

        // Save/Load functions
        function saveToStorage() {
            try {
                const data = {
                    score: state.score,
                    history: state.history.slice(-100),
                    statsHistory: state.statsHistory.slice(-100),
                    recentAnswers: state.recentAnswers.slice(-100),
                    settings: {
                        timePerQuestion: state.timePerQuestion,
                        networkComplexity: state.networkComplexity,
                        darkMode: state.darkMode,
                        useLetters: state.useLetters,
                        useEmojis: state.useEmojis,
                        useVoronoi: state.useVoronoi,
                        useMandelbrot: state.useMandelbrot,
                        letterLength: state.letterLength,
                        autoProgressEnabled: state.autoProgressEnabled,
                        universalAutoProgress: state.universalAutoProgress,
                        targetPremiseCount: state.targetPremiseCount,
                        targetAccuracy: state.targetAccuracy,
                        enabledRelationModes: state.enabledRelationModes,
                        premiseCounts: state.premiseCounts,
                        modeProgress: state.modeProgress
                    }
                };
                localStorage.setItem('rft-data', JSON.stringify(data));
            } catch (e) {
                console.error('Save failed:', e);
            }
        }

        function loadFromStorage() {
            try {
                const data = localStorage.getItem('rft-data');
                if (data) {
                    const parsed = JSON.parse(data);
                    if (parsed.score) state.score = parsed.score;
                    if (parsed.history) state.history = parsed.history;
                    if (parsed.statsHistory) state.statsHistory = parsed.statsHistory;
                    if (parsed.recentAnswers) state.recentAnswers = parsed.recentAnswers;
                    if (parsed.settings) {
                        Object.assign(state, parsed.settings);
                    }
                }
            } catch (e) {
                console.log('No saved data');
            }
        }

        // Relation logic
        function getRelationMode(relation) {
            if (['SAME', 'OPPOSITE', 'DIFFERENT'].includes(relation)) return 'equality';
            if (['BEFORE', 'AFTER', 'AT'].includes(relation)) return 'temporal';
            if (['CONTAINS', 'WITHIN'].includes(relation)) return 'containment';
            return 'spatial';
        }

        function deriveRelation(rel1, rel2) {
            const mode1 = getRelationMode(rel1);
            const mode2 = getRelationMode(rel2);
            if (mode1 !== mode2) return 'AMBIGUOUS';
            
            if (mode1 === 'equality') {
                if (rel1 === 'SAME') return rel2;
                if (rel2 === 'SAME') return rel1;
                if (rel1 === 'OPPOSITE' && rel2 === 'OPPOSITE') return 'SAME';
                return 'AMBIGUOUS';
            } else if (mode1 === 'temporal') {
                if (rel1 === 'AT') return rel2;
                if (rel2 === 'AT') return rel1;
                if (rel1 === 'BEFORE' && rel2 === 'BEFORE') return 'BEFORE';
                if (rel1 === 'AFTER' && rel2 === 'AFTER') return 'AFTER';
                return 'AMBIGUOUS';
            } else if (mode1 === 'containment') {
                if (rel1 === 'CONTAINS' && rel2 === 'CONTAINS') return 'CONTAINS';
                if (rel1 === 'WITHIN' && rel2 === 'WITHIN') return 'WITHIN';
                return 'AMBIGUOUS';
            } else {
                return rel1 === rel2 ? rel1 : 'AMBIGUOUS';
            }
        }

        function findAllPaths(graph, start, end, currentPath = [], visited = new Set(), allPaths = []) {
            if (start === end && currentPath.length > 0) {
                allPaths.push([...currentPath]);
                return allPaths;
            }
            visited.add(start);
            for (const edge of graph) {
                let nextNode = null, edgeToAdd = null;
                if (edge.stimulus1 === start && !visited.has(edge.stimulus2)) {
                    nextNode = edge.stimulus2;
                    edgeToAdd = { ...edge };
                } else if (edge.stimulus2 === start && !visited.has(edge.stimulus1)) {
                    nextNode = edge.stimulus1;
                    const reversedRelation = edge.relation === 'CONTAINS' ? 'WITHIN' : 
                                            edge.relation === 'WITHIN' ? 'CONTAINS' : edge.relation;
                    edgeToAdd = { ...edge, relation: reversedRelation };
                }
                if (nextNode) {
                    currentPath.push(edgeToAdd);
                    findAllPaths(graph, nextNode, end, currentPath, new Set(visited), allPaths);
                    currentPath.pop();
                }
            }
            return allPaths;
        }

        function deriveFromPath(path) {
            if (!path || path.length === 0) return null;
            let result = path[0].relation;
            for (let i = 1; i < path.length; i++) {
                result = deriveRelation(result, path[i].relation);
                if (result === 'AMBIGUOUS') return 'AMBIGUOUS';
            }
            return result;
        }

        function deriveRelationFromGraph(graph, start, end) {
            if (start === end) {
                if (state.enabledRelationModes.equality) return 'SAME';
                if (state.enabledRelationModes.temporal) return 'AT';
                return null;
            }
            const allPaths = findAllPaths(graph, start, end);
            if (allPaths.length === 0) return null;
            
            const derivedRelations = allPaths.map(path => deriveFromPath(path)).filter(r => r);
            if (derivedRelations.length === 0) return null;
            
            const nonAmbiguous = derivedRelations.filter(r => r !== 'AMBIGUOUS');
            if (nonAmbiguous.length === 0) return 'AMBIGUOUS';
            
            const firstRel = nonAmbiguous[0];
            return nonAmbiguous.every(rel => rel === firstRel) ? firstRel : 'AMBIGUOUS';
        }

        // Stimulus generation
        function generateStimulus() {
            const types = [];
            if (state.useLetters) types.push('letters');
            if (state.useEmojis) types.push('emojis');
            if (state.useVoronoi) types.push('voronoi');
            if (state.useMandelbrot) types.push('mandelbrot');
            if (types.length === 0) types.push('letters');
            
            const type = types[Math.floor(Math.random() * types.length)];
            
            if (type === 'emojis') {
                return emojiList[Math.floor(Math.random() * emojiList.length)];
            } else if (type === 'voronoi') {
                return 'voronoi_' + Math.floor(Math.random() * 1000000);
            } else if (type === 'mandelbrot') {
                return 'mandelbrot_' + Math.floor(Math.random() * 1000000);
            } else {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < state.letterLength; i++) {
                    result += chars[Math.floor(Math.random() * chars.length)];
                }
                return result;
            }
        }

        function generateVoronoiSVG(seed) {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
            const random = (s) => { const x = Math.sin(s++) * 10000; return x - Math.floor(x); };
            let svg = '<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="border-radius: 0.375rem;">';
            const gridSize = 4, tileSize = 16;
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const color = colors[Math.floor(random(seed + row * gridSize + col) * colors.length)];
                    svg += `<rect x="${col * tileSize}" y="${row * tileSize}" width="${tileSize}" height="${tileSize}" fill="${color}" opacity="0.9"/>`;
                }
            }
            return svg + '</svg>';
        }

        function generateMandelbrotSVG(seed) {
            const random = (s) => { const x = Math.sin(s++) * 10000; return x - Math.floor(x); };
            const centerX = -0.7 + (random(seed) - 0.5) * 0.5;
            const centerY = (random(seed + 100) - 0.5) * 0.5;
            const zoom = 0.3 + random(seed + 200) * 0.7;
            const size = 32, maxIter = 30;
            
            let svg = '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="border-radius: 0.375rem;">';
            const colors = ['#000033', '#0000AA', '#0055FF', '#00FFFF'];
            
            for (let py = 0; py < size; py++) {
                for (let px = 0; px < size; px++) {
                    const x0 = centerX + (px / size - 0.5) * zoom;
                    const y0 = centerY + (py / size - 0.5) * zoom;
                    let x = 0, y = 0, iteration = 0;
                    
                    while (x * x + y * y <= 4 && iteration < maxIter) {
                        const xtemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xtemp;
                        iteration++;
                    }
                    
                    const color = iteration === maxIter ? '#000000' : colors[Math.floor((iteration / maxIter) * (colors.length - 1))];
                    svg += `<rect x="${px}" y="${py}" width="1" height="1" fill="${color}"/>`;
                }
            }
            return svg + '</svg>';
        }

        // Trial generation
        function generateTrial() {
            const enabledModes = Object.keys(state.enabledRelationModes).filter(m => state.enabledRelationModes[m]);
            const mode = enabledModes[Math.floor(Math.random() * enabledModes.length)] || 'equality';
            const relations = relationSets[mode];
            const premiseCount = state.premiseCounts[mode];
            const numStimuli = Math.max(3, premiseCount + 1);
            
            const stimuli = [generateStimulus()];
            const premises = [];
            
            for (let p = 0; p < premiseCount; p++) {
                if (stimuli.length < numStimuli && Math.random() < 0.5) {
                    const newStim = generateStimulus();
                    stimuli.push(newStim);
                    premises.push({
                        stimulus1: stimuli[Math.floor(Math.random() * (stimuli.length - 1))],
                        relation: relations[Math.floor(Math.random() * relations.length)],
                        stimulus2: newStim
                    });
                } else if (stimuli.length >= 2) {
                    const i = Math.floor(Math.random() * stimuli.length);
                    let j = Math.floor(Math.random() * stimuli.length);
                    if (i === j) j = (j + 1) % stimuli.length;
                    premises.push({
                        stimulus1: stimuli[i],
                        relation: relations[Math.floor(Math.random() * relations.length)],
                        stimulus2: stimuli[j]
                    });
                }
            }
            
            const startIdx = Math.floor(Math.random() * stimuli.length);
            let endIdx = Math.floor(Math.random() * stimuli.length);
            if (startIdx === endIdx) endIdx = (endIdx + 1) % stimuli.length;
            
            const derivedRelation = deriveRelationFromGraph(premises, stimuli[startIdx], stimuli[endIdx]);
            let questionRelation, correctAnswer;
            
            if (derivedRelation === 'AMBIGUOUS' || derivedRelation === null) {
                questionRelation = relations[Math.floor(Math.random() * relations.length)];
                correctAnswer = 'ambiguous';
            } else {
                if (Math.random() < 0.5) {
                    questionRelation = derivedRelation;
                    correctAnswer = true;
                } else {
                    const others = relations.filter(r => r !== derivedRelation);
                    questionRelation = others.length > 0 ? others[Math.floor(Math.random() * others.length)] : derivedRelation;
                    correctAnswer = questionRelation === derivedRelation;
                }
            }

            return {
                premises,
                question: { stimulus1: stimuli[startIdx], relation: questionRelation, stimulus2: stimuli[endIdx] },
                correctAnswer,
                mode
            };
        }

        // Game flow
        function startNewTrial() {
            state.currentTrial = generateTrial();
            state.timeLeft = state.modeProgress[state.currentTrial.mode].timePerQuestion;
            state.feedback = null;
            render();
            startTimer();
        }

        function startTimer() {
            if (timerId) clearInterval(timerId);
            timerId = setInterval(() => {
                if (!state.isPaused && !state.feedback && state.timeLeft > 0) {
                    state.timeLeft = Math.max(0, state.timeLeft - 0.1);
                    render();
                    if (state.timeLeft <= 0) handleTimeout();
                }
            }, 100);
        }

        function handleTimeout() {
            state.score.missed++;
            state.feedback = 'missed';
            const mode = state.currentTrial.mode;
            state.history.push({
                userAnswer: null,
                isCorrect: false,
                timestamp: Date.now(),
                premiseCount: state.currentTrial.premises.length
            });
            state.recentAnswers.push(false);
            state.modeProgress[mode].recentAnswers.push(false);
            checkAutoProgress(mode);
            render();
            saveToStorage();
            setTimeout(() => startNewTrial(), 1500);
        }

        function handleAnswer(userAnswer) {
            if (state.isPaused || state.feedback) return;
            
            const isCorrect = userAnswer === state.currentTrial.correctAnswer;
            const mode = state.currentTrial.mode;
            
            if (isCorrect) state.score.correct++;
            else state.score.incorrect++;
            
            state.feedback = isCorrect ? 'correct' : 'incorrect';
            state.history.push({
                userAnswer,
                isCorrect,
                timestamp: Date.now(),
                premiseCount: state.currentTrial.premises.length
            });
            state.recentAnswers.push(isCorrect);
            state.modeProgress[mode].recentAnswers.push(isCorrect);
            checkAutoProgress(mode);
            render();
            saveToStorage();
            setTimeout(() => startNewTrial(), 1500);
        }

        function checkAutoProgress(mode) {
            if (!state.autoProgressEnabled) return;
            
            const data = state.universalAutoProgress ? state : state.modeProgress[mode];
            if (data.recentAnswers.length < state.targetPremiseCount) return;
            
            const recent = data.recentAnswers.slice(-state.targetPremiseCount);
            const accuracy = (recent.filter(a => a).length / state.targetPremiseCount) * 100;
            
            if (accuracy >= state.targetAccuracy) {
                if (state.universalAutoProgress) {
                    if (state.timePerQuestion > 10) {
                        state.timePerQuestion = Math.max(10, state.timePerQuestion - 5);
                        Object.keys(state.modeProgress).forEach(m => {
                            state.modeProgress[m].timePerQuestion = state.timePerQuestion;
                        });
                    } else {
                        Object.keys(state.premiseCounts).forEach(m => {
                            state.premiseCounts[m] = Math.min(100, state.premiseCounts[m] + 1);
                        });
                        state.timePerQuestion = 30;
                        Object.keys(state.modeProgress).forEach(m => {
                            state.modeProgress[m].timePerQuestion = 30;
                        });
                    }
                    state.recentAnswers = [];
                } else {
                    const modeData = state.modeProgress[mode];
                    if (modeData.timePerQuestion > 10) {
                        modeData.timePerQuestion = Math.max(10, modeData.timePerQuestion - 5);
                    } else {
                        state.premiseCounts[mode] = Math.min(100, state.premiseCounts[mode] + 1);
                        modeData.timePerQuestion = 30;
                    }
                    modeData.recentAnswers = [];
                }
            }
        }

        function togglePause() {
            state.isPaused = !state.isPaused;
            if (!state.isPaused) {
                startNewTrial();
            }
            render();
        }

        function resetGame() {
            if (!confirm('Reset all progress? This cannot be undone.')) return;
            state.score = { correct: 0, incorrect: 0, missed: 0 };
            state.history = [];
            state.recentAnswers = [];
            state.statsHistory = [];
            state.modeProgress = {
                equality: { recentAnswers: [], timePerQuestion: 30 },
                temporal: { recentAnswers: [], timePerQuestion: 30 },
                spatial: { recentAnswers: [], timePerQuestion: 30 },
                containment: { recentAnswers: [], timePerQuestion: 30 }
            };
            saveToStorage();
            startNewTrial();
        }

        // Utility functions
        function getAnswerLabel(answer) {
            if (answer === true) return 'YES';
            if (answer === false) return 'NO';
            if (answer === 'ambiguous') return "CAN'T TELL";
            return 'NO ANSWER';
        }

        function getRelationColor(relation) {
            const colorMap = {
                light: {
                    SAME: 'bg-green-100 text-green-700 border-green-300',
                    OPPOSITE: 'bg-red-100 text-red-700 border-red-300',
                    DIFFERENT: 'bg-blue-100 text-blue-700 border-blue-300',
                    BEFORE: 'bg-purple-100 text-purple-700 border-purple-300',
                    AFTER: 'bg-orange-100 text-orange-700 border-orange-300',
                    AT: 'bg-cyan-100 text-cyan-700 border-cyan-300',
                    CONTAINS: 'bg-blue-100 text-blue-700 border-blue-300',
                    WITHIN: 'bg-green-100 text-green-700 border-green-300',
                    spatial: 'bg-teal-100 text-teal-700 border-teal-300'
                },
                dark: {
                    SAME: 'bg-green-900/40 text-green-300 border-green-500',
                    OPPOSITE: 'bg-red-900/40 text-red-300 border-red-500',
                    DIFFERENT: 'bg-blue-900/40 text-blue-300 border-blue-500',
                    BEFORE: 'bg-purple-900/40 text-purple-300 border-purple-500',
                    AFTER: 'bg-orange-900/40 text-orange-300 border-orange-500',
                    AT: 'bg-cyan-900/40 text-cyan-300 border-cyan-500',
                    CONTAINS: 'bg-blue-900/40 text-blue-300 border-blue-500',
                    WITHIN: 'bg-green-900/40 text-green-300 border-green-500',
                    spatial: 'bg-teal-900/40 text-teal-300 border-teal-500'
                }
            };
            const mode = state.darkMode ? 'dark' : 'light';
            if (['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTHEAST', 'NORTHWEST', 'SOUTHEAST', 'SOUTHWEST'].includes(relation)) {
                return colorMap[mode].spatial;
            }
            return colorMap[mode][relation] || colorMap[mode].SAME;
        }

        function renderStimulus(stimulus) {
            if (stimulus.startsWith('voronoi_')) {
                const seed = parseInt(stimulus.split('_')[1]);
                return `<div class="w-16 h-16">${generateVoronoiSVG(seed)}</div>`;
            } else if (stimulus.startsWith('mandelbrot_')) {
                const seed = parseInt(stimulus.split('_')[1]);
                return `<div class="w-16 h-16">${generateMandelbrotSVG(seed)}</div>`;
            } else if (emojiList.includes(stimulus)) {
                return `<span class="emoji-stimulus">${stimulus}</span>`;
            }
            return `<span class="text-2xl font-bold">${stimulus}</span>`;
        }

        // Render function
        function render() {
            const app = document.getElementById('app');
            if (!app) return;

            const bg = state.darkMode ? 'bg-gray-900' : 'bg-gray-50';
            const text = state.darkMode ? 'text-gray-100' : 'text-gray-900';
            const card = state.darkMode ? 'bg-gray-800 text-gray-100' : 'bg-white text-gray-900';
            const secondary = state.darkMode ? 'bg-gray-700' : 'bg-gray-100';
            
            // Paused screen
            if (state.isPaused) {
                app.innerHTML = `
                    <div class="${bg} ${text} min-h-screen flex items-center justify-center p-4">
                        <div class="${card} rounded-lg shadow-xl p-8 max-w-md w-full">
                            <h1 class="text-3xl font-bold mb-6 text-center">Paused</h1>
                            <div class="space-y-4 mb-8">
                                <div class="flex justify-between p-4 ${secondary} rounded">
                                    <span>Correct:</span>
                                    <span class="text-green-500 font-bold text-xl">${state.score.correct}</span>
                                </div>
                                <div class="flex justify-between p-4 ${secondary} rounded">
                                    <span>Incorrect:</span>
                                    <span class="text-red-500 font-bold text-xl">${state.score.incorrect}</span>
                                </div>
                                <div class="flex justify-between p-4 ${secondary} rounded">
                                    <span>Missed:</span>
                                    <span class="text-yellow-500 font-bold text-xl">${state.score.missed}</span>
                                </div>
                            </div>
                            <div class="space-y-3">
                                <button onclick="window.togglePause()" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold">Resume</button>
                                <button onclick="window.showSettings()" class="w-full ${secondary} hover:opacity-80 px-6 py-3 rounded-lg font-semibold">Settings</button>
                                <button onclick="window.showHistory()" class="w-full ${secondary} hover:opacity-80 px-6 py-3 rounded-lg font-semibold">History</button>
                                <button onclick="window.showStats()" class="w-full ${secondary} hover:opacity-80 px-6 py-3 rounded-lg font-semibold">Statistics</button>
                                <button onclick="window.resetGame()" class="w-full bg-red-500 hover:bg-red-600 text-white px-6 py-3 rounded-lg font-semibold">Reset Progress</button>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            // Settings screen
            if (state.showSettings) {
                app.innerHTML = `
                    <div class="${bg} ${text} min-h-screen p-4 overflow-y-auto">
                        <div class="max-w-2xl mx-auto ${card} rounded-lg shadow-xl p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-2xl font-bold">Settings</h2>
                                <button onclick="window.closeSettings()" class="text-3xl">&times;</button>
                            </div>
                            <div class="space-y-6">
                                <div>
                                    <label class="flex items-center cursor-pointer">
                                        <input type="checkbox" ${state.darkMode ? 'checked' : ''} onchange="window.toggleDark(this.checked)" class="mr-2">
                                        <span class="font-semibold">Dark Mode</span>
                                    </label>
                                </div>
                                <div>
                                    <label class="block mb-2 font-semibold">Stimulus Types</label>
                                    <div class="space-y-2">
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.useLetters ? 'checked' : ''} onchange="window.toggleStimulus('useLetters', this.checked)" class="mr-2">
                                            <span>Letters</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.useEmojis ? 'checked' : ''} onchange="window.toggleStimulus('useEmojis', this.checked)" class="mr-2">
                                            <span>Emojis</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.useVoronoi ? 'checked' : ''} onchange="window.toggleStimulus('useVoronoi', this.checked)" class="mr-2">
                                            <span>Voronoi Patterns</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.useMandelbrot ? 'checked' : ''} onchange="window.toggleStimulus('useMandelbrot', this.checked)" class="mr-2">
                                            <span>Mandelbrot Fractals</span>
                                        </label>
                                    </div>
                                </div>
                                <div>
                                    <label class="block mb-2 font-semibold">Letter Length: ${state.letterLength}</label>
                                    <input type="range" min="1" max="5" value="${state.letterLength}" oninput="window.setLetterLength(this.value)" class="w-full">
                                </div>
                                <div>
                                    <label class="block mb-2 font-semibold">Network Complexity: ${Math.round(state.networkComplexity * 100)}%</label>
                                    <input type="range" min="0" max="100" value="${Math.round(state.networkComplexity * 100)}" oninput="window.setComplexity(this.value)" class="w-full">
                                </div>
                                <div>
                                    <label class="block mb-2 font-semibold">Relation Modes</label>
                                    <div class="space-y-2">
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.enabledRelationModes.equality ? 'checked' : ''} onchange="window.toggleMode('equality', this.checked)" class="mr-2">
                                            <span>Equality (SAME, OPPOSITE, DIFFERENT)</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.enabledRelationModes.temporal ? 'checked' : ''} onchange="window.toggleMode('temporal', this.checked)" class="mr-2">
                                            <span>Temporal (BEFORE, AFTER, AT)</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.enabledRelationModes.spatial ? 'checked' : ''} onchange="window.toggleMode('spatial', this.checked)" class="mr-2">
                                            <span>Spatial (NORTH, SOUTH, etc.)</span>
                                        </label>
                                        <label class="flex items-center cursor-pointer">
                                            <input type="checkbox" ${state.enabledRelationModes.containment ? 'checked' : ''} onchange="window.toggleMode('containment', this.checked)" class="mr-2">
                                            <span>Containment (CONTAINS, WITHIN)</span>
                                        </label>
                                    </div>
                                </div>
                                <div>
                                    <label class="flex items-center cursor-pointer">
                                        <input type="checkbox" ${state.autoProgressEnabled ? 'checked' : ''} onchange="window.toggleAuto(this.checked)" class="mr-2">
                                        <span class="font-semibold">Auto-Progress</span>
                                    </label>
                                </div>
                                ${state.autoProgressEnabled ? `
                                <div>
                                    <label class="block mb-2 font-semibold">Target Accuracy: ${state.targetAccuracy}%</label>
                                    <input type="range" min="50" max="100" value="${state.targetAccuracy}" oninput="window.setTargetAccuracy(this.value)" class="w-full">
                                </div>
                                <div>
                                    <label class="block mb-2 font-semibold">Sample Size: ${state.targetPremiseCount} trials</label>
                                    <input type="range" min="10" max="100" value="${state.targetPremiseCount}" oninput="window.setTargetPremise(this.value)" class="w-full">
                                </div>
                                ` : ''}
                            </div>
                            <button onclick="window.closeSettings()" class="mt-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold">Done</button>
                        </div>
                    </div>
                `;
                return;
            }

            // History screen
            if (state.showHistory) {
                const recent = state.history.slice(-20).reverse();
                app.innerHTML = `
                    <div class="${bg} ${text} min-h-screen p-4 overflow-y-auto">
                        <div class="max-w-4xl mx-auto ${card} rounded-lg shadow-xl p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-2xl font-bold">Recent History</h2>
                                <button onclick="window.closeHistory()" class="text-3xl">&times;</button>
                            </div>
                            ${recent.length === 0 ? `<p class="text-center py-8 opacity-60">No history yet</p>` : `
                                <div class="space-y-4">
                                    ${recent.map(entry => `
                                        <div class="p-4 ${secondary} rounded-lg">
                                            <div class="flex justify-between items-start mb-2">
                                                <span class="${entry.isCorrect ? 'text-green-500' : 'text-red-500'} font-bold">
                                                    ${entry.isCorrect ? '‚úì Correct' : '‚úó Incorrect'}
                                                </span>
                                                <span class="text-sm opacity-60">${new Date(entry.timestamp).toLocaleTimeString()}</span>
                                            </div>
                                            <div class="text-sm">
                                                <p>Premises: ${entry.premiseCount}</p>
                                                <p>Your answer: ${getAnswerLabel(entry.userAnswer)}</p>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            `}
                            <button onclick="window.closeHistory()" class="mt-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold">Close</button>
                        </div>
                    </div>
                `;
                return;
            }

            // Stats screen
            if (state.showStats) {
                const total = state.score.correct + state.score.incorrect + state.score.missed;
                const accuracy = total > 0 ? ((state.score.correct / total) * 100).toFixed(1) : 0;
                app.innerHTML = `
                    <div class="${bg} ${text} min-h-screen p-4 overflow-y-auto">
                        <div class="max-w-2xl mx-auto ${card} rounded-lg shadow-xl p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-2xl font-bold">Statistics</h2>
                                <button onclick="window.closeStats()" class="text-3xl">&times;</button>
                            </div>
                            <div class="space-y-4">
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="p-4 ${secondary} rounded-lg text-center">
                                        <div class="text-3xl font-bold text-green-500">${state.score.correct}</div>
                                        <div class="text-sm">Correct</div>
                                    </div>
                                    <div class="p-4 ${secondary} rounded-lg text-center">
                                        <div class="text-3xl font-bold text-red-500">${state.score.incorrect}</div>
                                        <div class="text-sm">Incorrect</div>
                                    </div>
                                    <div class="p-4 ${secondary} rounded-lg text-center">
                                        <div class="text-3xl font-bold text-yellow-500">${state.score.missed}</div>
                                        <div class="text-sm">Missed</div>
                                    </div>
                                    <div class="p-4 ${secondary} rounded-lg text-center">
                                        <div class="text-3xl font-bold text-indigo-500">${total}</div>
                                        <div class="text-sm">Total</div>
                                    </div>
                                </div>
                                <div class="p-4 ${secondary} rounded-lg">
                                    <div class="flex justify-between">
                                        <span>Accuracy:</span>
                                        <span class="font-bold text-indigo-500">${accuracy}%</span>
                                    </div>
                                </div>
                            </div>
                            <button onclick="window.closeStats()" class="mt-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold">Close</button>
                        </div>
                    </div>
                `;
                return;
            }

            // Main game screen
            if (!state.currentTrial) {
                app.innerHTML = `<div class="${bg} ${text} min-h-screen flex items-center justify-center"><p>Loading...</p></div>`;
                return;
            }

            const trial = state.currentTrial;
            const progress = (state.timeLeft / state.modeProgress[trial.mode].timePerQuestion) * 100;
            let progressColor = 'bg-green-500';
            if (progress < 33) progressColor = 'bg-red-500';
            else if (progress < 66) progressColor = 'bg-yellow-500';

            app.innerHTML = `
                <div class="${bg} ${text} min-h-screen flex flex-col">
                    <div class="${card} shadow-md p-4">
                        <div class="max-w-4xl mx-auto flex justify-between items-center">
                            <button onclick="window.togglePause()" class="px-4 py-2 ${secondary} hover:opacity-80 rounded-lg">‚è∏ Pause</button>
                            <div class="flex gap-4 text-sm">
                                <span class="text-green-500 font-bold">‚úì ${state.score.correct}</span>
                                <span class="text-red-500 font-bold">‚úó ${state.score.incorrect}</span>
                                <span class="text-yellow-500 font-bold">‚äó ${state.score.missed}</span>
                            </div>
                        </div>
                    </div>
                    <div class="flex-1 flex items-center justify-center p-4 overflow-y-auto">
                        <div class="max-w-4xl w-full">
                            <div class="mb-6">
                                <div class="h-2 ${state.darkMode ? 'bg-gray-700' : 'bg-gray-300'} rounded-full overflow-hidden">
                                    <div class="${progressColor} h-full transition-all" style="width: ${progress}%"></div>
                                </div>
                                <div class="text-center mt-2 font-mono">${state.timeLeft.toFixed(1)}s</div>
                            </div>
                            <div class="${card} rounded-lg shadow-lg p-6 mb-6">
                                <h3 class="text-lg font-semibold mb-4">Given Information:</h3>
                                <div class="space-y-3">
                                    ${trial.premises.map(p => `
                                        <div class="flex items-center justify-center gap-4 p-3 ${secondary} rounded-lg">
                                            ${renderStimulus(p.stimulus1)}
                                            <div class="px-4 py-2 ${getRelationColor(p.relation)} border-2 rounded-lg font-semibold text-sm">${p.relation}</div>
                                            ${renderStimulus(p.stimulus2)}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            <div class="${card} rounded-lg shadow-lg p-6 mb-6">
                                <h3 class="text-lg font-semibold mb-4">Question:</h3>
                                <div class="flex items-center justify-center gap-4 p-4 ${secondary} rounded-lg">
                                    ${renderStimulus(trial.question.stimulus1)}
                                    <div class="px-4 py-2 ${getRelationColor(trial.question.relation)} border-2 rounded-lg font-semibold text-sm">${trial.question.relation}</div>
                                    ${renderStimulus(trial.question.stimulus2)}
                                </div>
                                <p class="text-center mt-4 text-lg">Is this relationship true?</p>
                            </div>
                            <div class="grid grid-cols-3 gap-4">
                                <button onclick="window.answer(true)" ${state.feedback ? 'disabled' : ''} class="py-4 bg-green-500 hover:bg-green-600 disabled:opacity-50 text-white rounded-lg font-bold text-lg">YES</button>
                                <button onclick="window.answer(false)" ${state.feedback ? 'disabled' : ''} class="py-4 bg-red-500 hover:bg-red-600 disabled:opacity-50 text-white rounded-lg font-bold text-lg">NO</button>
                                <button onclick="window.answer('ambiguous')" ${state.feedback ? 'disabled' : ''} class="py-4 bg-yellow-500 hover:bg-yellow-600 disabled:opacity-50 text-white rounded-lg font-bold text-lg">CAN'T TELL</button>
                            </div>
                            ${state.feedback ? `
                                <div class="mt-6 p-4 rounded-lg text-center font-bold text-lg ${
                                    state.feedback === 'correct' ? 'bg-green-500 text-white' :
                                    state.feedback === 'incorrect' ? 'bg-red-500 text-white' :
                                    'bg-yellow-500 text-white'
                                }">
                                    ${state.feedback === 'correct' ? '‚úì Correct!' : 
                                      state.feedback === 'incorrect' ? '‚úó Incorrect' : '‚äó Time\'s up!'}
                                    ${state.feedback !== 'correct' ? `<div class="text-sm mt-2">Correct: ${getAnswerLabel(trial.correctAnswer)}</div>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        // Expose functions to window
        window.togglePause = togglePause;
        window.resetGame = resetGame;
        window.answer = handleAnswer;
        window.showSettings = () => { state.showSettings = true; render(); };
        window.closeSettings = () => { state.showSettings = false; render(); };
        window.showHistory = () => { state.showHistory = true; render(); };
        window.closeHistory = () => { state.showHistory = false; render(); };
        window.showStats = () => { state.showStats = true; render(); };
        window.closeStats = () => { state.showStats = false; render(); };
        window.toggleDark = (val) => { state.darkMode = val; if (val) document.body.classList.add('dark'); else document.body.classList.remove('dark'); render(); };
        window.toggleStimulus = (key, val) => { state[key] = val; render(); };
        window.setLetterLength = (val) => { state.letterLength = parseInt(val); render(); };
        window.setComplexity = (val) => { state.networkComplexity = parseInt(val) / 100; render(); };
        window.toggleMode = (mode, val) => { state.enabledRelationModes[mode] = val; render(); };
        window.toggleAuto = (val) => { state.autoProgressEnabled = val; render(); };
        window.setTargetAccuracy = (val) => { state.targetAccuracy = parseInt(val); render(); };
        window.setTargetPremise = (val) => { state.targetPremiseCount = parseInt(val); render(); };

        // Initialize
        console.log('Initializing app...');
        try {
            loadFromStorage();
            if (state.darkMode) document.body.classList.add('dark');
            setTimeout(() => {
                startNewTrial();
                console.log('App initialized successfully!');
            }, 500);
        } catch (e) {
            console.error('Initialization error:', e);
            document.getElementById('app').innerHTML = '<div style="padding: 20px; text-align: center;">Error loading app. Please refresh.</div>';
        }
    </script>
</body>
</html>
